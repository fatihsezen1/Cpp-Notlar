##1. Ders## ve ##2. Ders##
- C dilinde static omurlu degiskenlere ilk deger veren ifadeler constant expression olmak zorunda fakan C++'ta boyle bir zorunluluk yok.
  Ornegin;
  int g_x = foo();  //C'de gecersiz, C++'da gecerli 

- C dilinde bir structure'in gecerli olmasi icin en az 1 elemani olmasi lazim. Fakat C++'ta 'empty class' legal ve cok kullaniliyor.

- C dilinde struct gibi user-defined turlerde degisken tanimlarken struct anahtar sozcugunu de kullanmak gerekiyor.
  Ornegin;
  struct person ali;   //C'de boyle
  person ali;   //C++'ta boyle de olur. (ustteki gibi de olur)

- C++'ta compound literal yok, C'de var.
  Ornegin;
  (int[5]) {1,3,4,5,6};

- C'de enum turlerinden temel turlere ve tersine ortulu donusum var.
  Ornegin asagidaki kod C'de legal;
  
  enum Color {
    White, Gray, Red
  };
  enum Pos {
    Open, Ajar, Close
  };

  int main() 
  {
	enum Color mycolor;
	int x = 2;

	enum Pos pos = Gray;
	mycolor = 5;
	mycolor = x;
	int ival = mycolor;
  }

- C++'ta enum turlerinden tam sayi turlerine ortulu donusum var. Bu ozellik Necati Ergin'e gore tam bir utanc kaynagi ve
	dilin genclik gunahi. Ornegin;

	#include <iostream>
	enum Color {
		White, Gray, Red
	};
	int main()
	{
		Color mycolor = Gray;
		int x = mycolor;	// enum turlerinden diger turlere yok, temel turlere ortulu donusum var
	}

- Bu durumu ortadan kaldirmak icin enum Class eklendi (scoped enums). Artik her zaman bu enum turlerini kullanacagiz.
  Bu enum turlerini ileride isleyecegiz.

- C23'e kadar C'de enum turu int idi. c23 ile c'ye de eklenen underlying type ozelligini kullanarak enumartorlerin tipini biz 
  belirleyebiliyoruz.
  Ornegin;

  enum Color : unsigned char {White, Gray, Red};

- C++ standartlarinda main fonksiyonunun int olmasi zorunlu. Ama derleyiciler yine de derliyor.

- C++'ta main fonksiyonunda return 0; yazmazsan derleyici kendisi yaziyor.

- int foo(void)
  {
        //..
  }

  Bu fonksiyon C'de undetermined value dondurur. ancak C++'da sentaks hatasi. (return yok)

- C'de main icinde main recursive olarak cagrilabiliyor. Ancak C++'ta bu cagrim sentaks hatasi.

- C++'ta;
  T x; //default initialization. Indetermined value ile hayata gelir. Bu artik kotu bir teknik.

- zero-initilization isminde initilization gecmesine ragmen bir ilkdeger kategorisi degil!!!! 
  Bazi init kategorilerinde uygulanan bir surec. (sifirla, nullptr ile, false ile ilk deger vermek)

  static omurlu degiskenler zero-init sureci... 

- T x = expr;         //artik buna copy initialization diyoruz.

- int x(7);        //bu c'de yok. Direct initilization diyoruz.

- uniform initilization(standartlardaki ismi) == brace initilization(populer ismi)
  Bunu direct initilizationda kullanmak cok daha yaygin. Hem her seye boyle ilkdeger verebiliyoruz hem de daraltici 
  donusume (narrowing conversion) izin vermiyor.

  Ornegin;
        int x = val;        //copy init
        int y(val);        //direct init
        int z{val};        //direct list init

- bazi ifadeler hem bir function prototype hem de variable definition anlamina gelebiliyorsa burada fonksiyon bildiriminin 
  onceligi var.!!! Scot-meyers reis buna bir tanim uydurmus -> most vexing parse

  Bir Most Vexing Parse ornegi;

        class A {

	};
	
	class B {
		B(A);
	};
	
	int main()
	{
		B bx(A());	//burada ismi bx olan bir degisken tanimlanmiyor. Bu bir fonksiyon BILDIRIMI!
	}
	
	Bunun bir fonksiyon bildirimi yerine bir degisken tanimlamasi olmasi icin UNIFORM INITIALIZER SYNTAX kullanmamiz gerekiyordu.
	Yani su sekilde:
	
	B bx{ A() };
	  
Ozetle neden uniform init sentaksa ihtiyac duyulmus?
	*uniform olmasi
	*daraltici donusume izin vermemesi
	*most vexing parse'a izin vermemesi


- value initialization:
  int x{};	// value initializationun farki, ilk basamak olarak zero-init kullanilmasi. Burada x sifir degerinde. yani cop deger yerine sifir ile
   		   baslatmis olduk. 

- nullptr sabitinin turu nullptr_t. nullptr nullptr_t turunden bir SABIT.
         
- unaveluated context -> islem kodu uretilmeyen baglam
  ne demek bu unaveluated context?
  oyle yerler var ki dilin kurali geregi o ifade icin islem kodu uretilmiyor. C dilindeki tek ornegi sizeof operatoru:

  int x = 10;
  size_t sz = sizeof(x++);	// burada x degiskeninin degeri hala 10

  sizeof operatorunun operandi olan ifade icin islem kodu uretilmez.

  C++'ta bu konu bir kac farkli yerde karsimiza cikiyor. Bu durum tanimsiz davranis dogurmuyor.
  C++ icin ornekler:

  int(*p)[10] = malloc(sizeof(*p));
	soru: malloc fonksiyonuna arguman olarak ne gectik?
	cevap: *p ifadesinin degeri int*[10] yani 10 carpi sizeof int degerini gectim. Buradaki problem p'yi dereference etmis olduk. ama p henuz cop degerde. ama sizeof icinde
		oldugu icin unevaluated context oluyor, yani tanimsiz davranis olusturmuyor. Cunku sizeof icin islem kodu uretilmez.

  int a[4] = {0};
  sizeof(a[5]);		// a[5] normalde tanimsiz davranis ama islem kodu uretilmedigi icin unevaluated context.

 int *ptr = nullptr;
 decltype(*ptr);	// burada da unaveluated context oldugu icin nullptr'yi dereference etmek sorun olusturmuyor.
	

##3. Ders##

- Referans semantigi

  C'deki pointerlar yerine C++ dilinde sunlar kullanilabilir:
  pointer, referans, smart pointer (bir sinifla temsil edilir), iteratorler

  3 tane referans kategorisi var:

  L value reference
  R value reference
  forwarding reference (universal ref.)

  hatirlatma:

  expression (ifade nedir)
  10
  x
  x + y

  bunlarin sonuna terminator atomu yani ; koyarsak statement olur.

  x;  -> mesela bu bir expression statement

  her ifadenin bir value kategorisi var.
  modern C++ ile tasima semantigi icin bu value kategorisi biraz degisti:

  primary value category
  	L value (Left val.)
	PR value (pure val.)
	X value (expiring val.)

  combined value category
	L value	 ya da	X value  -> 	GL value
	PR Value ya da 	X value  ->	R value


	   glvalue     rvalue			(combined value cat.)
	    /  \       /  \
	   /    \     /    \
	lvalue   xvalue    prvalue		(primary value cat.)


	C ve C++'dan bazi farkliliklar:
	
	++x
	--y 
	
	ifadelerinin deger kategorileri C'de R value, C++'ta L value
	
	ya da 
	
	x, y
	Bu ifade operandlari L value olsa bile C'de L value degil ancak C++'ta ikinci operator L value ise ifade L val expr olusturuyor.


  Referanslara devam edelim.

  int x = 10;
  int& r{x};	//alias, r demek x demek...

- bir referans bir degiskene bind oldugunda sonra baska degiskene bind edilemez.
- referanslar default initialize edilemez. Ilkdeger vermek zorunludur.
- yukaridaki kodda &r demek x'in adresi demek.
- int* const p = &x; -> const pointer to int, top level const, right const yani pointerin kendisi const. gosterdigi nesne const degil.
- const int* p = &x; ->  pointer to const int, low level const, left const yani pointerin kendisi const degil. gosterdigi nesne const.
- const int* const p = &x; ->  const pointer to const int. gosteren de gosterilen de const.

- iste L value referans sunun karsiligi 
	int x = 19;
	int* const p = &x;	//L val ref.ler rebindable degil bu yuzden const pointer to int gibi dusunebilirisin.
	int& r{x};
 
- ornek:
	int x{};
	int* p = &x;
	//p'nin yerine gececek r isimle L value ref tanimlarsak;
	int* & r{p};

	++*r;	//r demek p demek, dereferans p demek x demek, dolayisiyla x'i 0'dan 1'e arttirmis oluruz.


- T foo();	-> boyle bir fonksiyona yapilan cagri ifadesi R value expression
- T& foo();	-> boyle bir fonksiyona yapilan cagri ifadesi L value expression

	int g_x = 11;
	int& foo()
	{
		//..
		return g_x;
	}
	int main()
	{
		foo() = 234; //atamayi g_x degiskenine yapmis oluyorum.
		int& r {foo()};	
	}

- dolayisiyla asagidaki gibi fonksiyonlara mutator, set-function ya da setter deniyor
	void func(T &);



- Oyle bir referans tanimla ki a'ya bind edilsin:
	int a[5] {0};
	//a dizisini gosteren pointer -> int(*p)[5] = &a;
	int(&r)[5] = a;



- const correctness = const olmasi gereken her sey const olmali

	ornegin fonksiyon parametresi const olmasi gerekirken olmazsa const nesneleri arguman gecemeyiz. Ornegin;

	#include <iostream>
	using namespace std;
	
	void print_array(int* p, size_t size);
	
	int main()
	{
		const int a[5]{};
		print_array(a, 5);	//error: 'void print_array(int *,size_t)': cannot convert argument 1 from 'const int [5]' to 'int *
	}


	// iste const bir yerden bile eksik olursa her yere nufuz eder. Derleyici optimizasyon olanaklarini kisitlar.


- int x = 10;
  const int& r = x;	//salt okunur bir referans. Amac degistirmeye yonelik degilse bu kullanilmali. (Accessor)

- int& r{10}; 	//sentaks hatasi! neden? Cunku 10 L value expression degil.
- const int& r{10}; 	//sentaks hatasi degil. neden?
	bu durumda r referansi bu sabite BAGLANMIYOR. Derleyici bir TEMPORARY OBJECT olusturuyor. 
- double x{2.6};
  const int& r = x;		//burada sentaks hatasi yok. temporary object 2 degerini alir. const olmasa sentaks hatasi olurdu. 
	
SONUCTA;
parameteresi T & olan fonksiyon sadece L Value expression kabul eder,
parameteresi const  T & olan fonksiyon hem R value expr hem de  L Value expression kabul eder.



- C++11 ile gelen onemli 5-6 eklentiden bazilari : tasima semantigi, lambda ifadeleri, perfect forwarding
  bunlarda R value referans kategorisi kullanilacak.

- T && seklinde kullanilan referans R value referans belirtir.
- R value referans R value expression'a baglaniyor. L value expressiona baglanamiyor.
- R value expressionun L value referans baglanmasi sentaks hatasidir.
- L value expressionun R value referans baglanmasi sentaks hatasidir.

ozetle:
T &      ->	sadece L value expression'a baglanir.
const T& -> 	hem L hem R value expressiona baglanir.
T &&     -> 	sadece R value expression'a baglanir. 

##4. Ders##
 
