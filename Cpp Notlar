##1. Ders## ve ##2. Ders##
- C dilinde static omurlu degiskenlere ilk deger veren ifadeler constant expression olmak zorunda fakan C++'ta boyle bir zorunluluk yok.
  Ornegin;
  int g_x = foo();  //C'de gecersiz, C++'da gecerli 

- C dilinde bir structure'in gecerli olmasi icin en az 1 elemani olmasi lazim. Fakat C++'ta 'empty class' legal ve cok kullaniliyor.

- C dilinde struct gibi user-defined turlerde degisken tanimlarken struct anahtar sozcugunu de kullanmak gerekiyor.
  Ornegin;
  struct person ali;   //C'de boyle
  person ali;   //C++'ta boyle de olur. (ustteki gibi de olur)

- C++'ta compound literal yok, C'de var.
  Ornegin;
  (int[5]) {1,3,4,5,6};

- C'de enum turlerinden temel turlere ve tersine ortulu donusum var.
  Ornegin asagidaki kod C'de legal;
  
  enum Color {
    White, Gray, Red
  };
  enum Pos {
    Open, Ajar, Close
  };

  int main() 
  {
	enum Color mycolor;
	int x = 2;

	enum Pos pos = Gray;
	mycolor = 5;
	mycolor = x;
	int ival = mycolor;
  }

- C++'ta enum turlerinden tam sayi turlerine ortulu donusum var. Bu ozellik Necati Ergin'e gore tam bir utanc kaynagi ve
	dilin genclik gunahi. Ornegin;

	#include <iostream>
	enum Color {
		White, Gray, Red
	};
	int main()
	{
		Color mycolor = Gray;
		int x = mycolor;	// enum turlerinden diger turlere yok, temel turlere ortulu donusum var
	}

- Bu durumu ortadan kaldirmak icin enum Class eklendi (scoped enums). Artik her zaman bu enum turlerini kullanacagiz.
  Bu enum turlerini ileride isleyecegiz.

- C23'e kadar C'de enum turu int idi. c23 ile c'ye de eklenen underlying type ozelligini kullanarak enumartorlerin tipini biz 
  belirleyebiliyoruz.
  Ornegin;

  enum Color : unsigned char {White, Gray, Red};

- C++ standartlarinda main fonksiyonunun int olmasi zorunlu. Ama derleyiciler yine de derliyor.

- C++'ta main fonksiyonunda return 0; yazmazsan derleyici kendisi yaziyor.

- int foo(void)
  {
        //..
  }

  Bu fonksiyon C'de undetermined value dondurur. ancak C++'da sentaks hatasi. (return yok)

- C'de main icinde main recursive olarak cagrilabiliyor. Ancak C++'ta bu cagrim sentaks hatasi.

- C++'ta;
  T x; //default initialization. Indetermined value ile hayata gelir. Bu artik kotu bir teknik.

- zero-initilization isminde initilization gecmesine ragmen bir ilkdeger kategorisi degil!!!! 
  Bazi init kategorilerinde uygulanan bir surec. (sifirla, nullptr ile, false ile ilk deger vermek)

  static omurlu degiskenler zero-init sureci... 

- T x = expr;         //artik buna copy initialization diyoruz.

- int x(7);        //bu c'de yok. Direct initilization diyoruz.

- uniform initilization(standartlardaki ismi) == brace initilization(populer ismi)
  Bunu direct initilizationda kullanmak cok daha yaygin. Hem her seye boyle ilkdeger verebiliyoruz hem de daraltici 
  donusume (narrowing conversion) izin vermiyor.

  Ornegin;
        int x = val;        //copy init
        int y(val);        //direct init
        int z{val};        //direct list init

- bazi ifadeler hem bir function prototype hem de variable definition anlamina gelebiliyorsa burada fonksiyon bildiriminin 
  onceligi var.!!! Scot-meyers reis buna bir tanim uydurmus -> most vexing parse

  Bir Most Vexing Parse ornegi;

        class A {

	};
	
	class B {
		B(A);
	};
	
	int main()
	{
		B bx(A());	//burada ismi bx olan bir degisken tanimlanmiyor. Bu bir fonksiyon BILDIRIMI!
	}
	
	Bunun bir fonksiyon bildirimi yerine bir degisken tanimlamasi olmasi icin UNIFORM INITIALIZER SYNTAX kullanmamiz gerekiyordu.
	Yani su sekilde:
	
	B bx{ A() };
	  
Ozetle neden uniform init sentaksa ihtiyac duyulmus?
	*uniform olmasi
	*daraltici donusume izin vermemesi
	*most vexing parse'a izin vermemesi


- value initialization:
  int x{};	// value initializationun farki, ilk basamak olarak zero-init kullanilmasi. Burada x sifir degerinde. yani cop deger yerine sifir ile
   		   baslatmis olduk. 

- nullptr sabitinin turu nullptr_t. nullptr nullptr_t turunden bir SABIT.
         
- unaveluated context -> islem kodu uretilmeyen baglam
  ne demek bu unaveluated context?
  oyle yerler var ki dilin kurali geregi o ifade icin islem kodu uretilmiyor. C dilindeki tek ornegi sizeof operatoru:

  int x = 10;
  size_t sz = sizeof(x++);	// burada x degiskeninin degeri hala 10

  sizeof operatorunun operandi olan ifade icin islem kodu uretilmez.

  C++'ta bu konu bir kac farkli yerde karsimiza cikiyor. Bu durum tanimsiz davranis dogurmuyor.
  C++ icin ornekler:

  int(*p)[10] = malloc(sizeof(*p));
	soru: malloc fonksiyonuna arguman olarak ne gectik?
	cevap: *p ifadesinin degeri int*[10] yani 10 carpi sizeof int degerini gectim. Buradaki problem p'yi dereference etmis olduk. ama p henuz cop degerde. ama sizeof icinde
		oldugu icin unevaluated context oluyor, yani tanimsiz davranis olusturmuyor. Cunku sizeof icin islem kodu uretilmez.

  int a[4] = {0};
  sizeof(a[5]);		// a[5] normalde tanimsiz davranis ama islem kodu uretilmedigi icin unevaluated context.

 int *ptr = nullptr;
 decltype(*ptr);	// burada da unaveluated context oldugu icin nullptr'yi dereference etmek sorun olusturmuyor.
	

##3. Ders##

- Referans semantigi

  C'deki pointerlar yerine C++ dilinde sunlar kullanilabilir:
  pointer, referans, smart pointer (bir sinifla temsil edilir), iteratorler

  3 tane referans kategorisi var:

  L value reference
  R value reference
  forwarding reference (universal ref.)

  hatirlatma:

  expression (ifade nedir)
  10
  x
  x + y

  bunlarin sonuna terminator atomu yani ; koyarsak statement olur.

  x;  -> mesela bu bir expression statement

  her ifadenin bir value kategorisi var.
  modern C++ ile tasima semantigi icin bu value kategorisi biraz degisti:

  primary value category
  	L value (Left val.)
	PR value (pure val.)
	X value (expiring val.)

  combined value category
	L value	 ya da	X value  -> 	GL value
	PR Value ya da 	X value  ->	R value


	   glvalue     rvalue			(combined value cat.)
	    /  \       /  \
	   /    \     /    \
	lvalue   xvalue    prvalue		(primary value cat.)


	C ve C++'dan bazi farkliliklar:
	
	++x
	--y 
	
	ifadelerinin deger kategorileri C'de R value, C++'ta L value
	
	ya da 
	
	x, y
	Bu ifade operandlari L value olsa bile C'de L value degil ancak C++'ta ikinci operator L value ise ifade L val expr olusturuyor.


  Referanslara devam edelim.

  int x = 10;
  int& r{x};	//alias, r demek x demek...

- bir referans bir degiskene bind oldugunda sonra baska degiskene bind edilemez.
- referanslar default initialize edilemez. Ilkdeger vermek zorunludur.
- yukaridaki kodda &r demek x'in adresi demek.
- int* const p = &x; -> const pointer to int, top level const, right const yani pointerin kendisi const. gosterdigi nesne const degil.
- const int* p = &x; ->  pointer to const int, low level const, left const yani pointerin kendisi const degil. gosterdigi nesne const.
- const int* const p = &x; ->  const pointer to const int. gosteren de gosterilen de const.

- iste L value referans sunun karsiligi 
	int x = 19;
	int* const p = &x;	//L val ref.ler rebindable degil bu yuzden const pointer to int gibi dusunebilirisin.
	int& r{x};
 
- ornek:
	int x{};
	int* p = &x;
	//p'nin yerine gececek r isimle L value ref tanimlarsak;
	int* & r{p};

	++*r;	//r demek p demek, dereferans p demek x demek, dolayisiyla x'i 0'dan 1'e arttirmis oluruz.


- T foo();	-> boyle bir fonksiyona yapilan cagri ifadesi R value expression
- T& foo();	-> boyle bir fonksiyona yapilan cagri ifadesi L value expression

	int g_x = 11;
	int& foo()
	{
		//..
		return g_x;
	}
	int main()
	{
		foo() = 234; //atamayi g_x degiskenine yapmis oluyorum.
		int& r {foo()};	
	}

- dolayisiyla asagidaki gibi fonksiyonlara mutator, set-function ya da setter deniyor
	void func(T &);



- Oyle bir referans tanimla ki a'ya bind edilsin:
	int a[5] {0};
	//a dizisini gosteren pointer -> int(*p)[5] = &a;
	int(&r)[5] = a;



- const correctness = const olmasi gereken her sey const olmali

	ornegin fonksiyon parametresi const olmasi gerekirken olmazsa const nesneleri arguman gecemeyiz. Ornegin;

	#include <iostream>
	using namespace std;
	
	void print_array(int* p, size_t size);
	
	int main()
	{
		const int a[5]{};
		print_array(a, 5);	//error: 'void print_array(int *,size_t)': cannot convert argument 1 from 'const int [5]' to 'int *
	}


	// iste const bir yerden bile eksik olursa her yere nufuz eder. Derleyici optimizasyon olanaklarini kisitlar.


- int x = 10;
  const int& r = x;	//salt okunur bir referans. Amac degistirmeye yonelik degilse bu kullanilmali. (Accessor)

- int& r{10}; 	//sentaks hatasi! neden? Cunku 10 L value expression degil.
- const int& r{10}; 	//sentaks hatasi degil. neden?
	bu durumda r referansi bu sabite BAGLANMIYOR. Derleyici bir TEMPORARY OBJECT olusturuyor. 
- double x{2.6};
  const int& r = x;		//burada sentaks hatasi yok. temporary object 2 degerini alir. const olmasa sentaks hatasi olurdu. 
	
SONUCTA;
parameteresi T & olan fonksiyon sadece L Value expression kabul eder,
parameteresi const  T & olan fonksiyon hem R value expr hem de  L Value expression kabul eder.



- C++11 ile gelen onemli 5-6 eklentiden bazilari : tasima semantigi, lambda ifadeleri, perfect forwarding
  bunlarda R value referans kategorisi kullanilacak.

- T && seklinde kullanilan referans R value referans belirtir.
- R value referans R value expression'a baglaniyor. L value expressiona baglanamiyor.
- R value expressionun L value referans baglanmasi sentaks hatasidir.
- L value expressionun R value referans baglanmasi sentaks hatasidir.

ozetle:
T &      ->	sadece L value expression'a baglanir.
const T& -> 	hem L hem R value expressiona baglanir.
T &&     -> 	sadece R value expression'a baglanir. 

##4. Ders##
 soru: asagidaki kodda bir problem var mi?
	
	#include <iostream>
	
	int& get_value()
	{
		std::cout << "enter an integer: ";
		int x{};
		std::cin >> x;
		return x;
	}
	
	int main()
	{
		int& ri = get_value();
		std::cout << ri << '\n';
		return 0;
	}
	
	cevap: evet, otomatik omurlu nesnenin referansini donduruyor. 20. satirda o degisken hakkin rahmetine kavusmus oluyor.
	
-default argument (varsayilan arguman):

- ornegin 
	int foo(int, int, int = 10);
- varsayilan argumanlarin hepsi en saga dayali olmasi gerekiyor.
  ornegin 
	int foo(int, int, int = 10, int ); // bu bir sentaks hatasi

- varsayilan arguman hem bildirimde hem tanimda olsa SENTAKS HATASI olacakti. Sadece fonksiyon bildiriminde yaziyoruz genelde.
- fonksiyonun parametresi referans olup varsayilan arguman alabilir.
- fonksiyonun  varsayilan argumani fonksiyon cagrisi alabilir.
- birden fazla fonksiyon bildirimi yapilabilir. bu bildirimler kumulatif olarak ele alinir. 
- daha onceki parametreler daha sonraki parametrelerde varsayilan arguman olarak kullanilamaz.



- type deduction ( tur cikarimi )
- auto type deduction
- C'deki auto otomatik omurlu oldugunu belirtmek icin olan bir keyword. Bu atil durumdaki sozcuge C++'ta yepyeni bir anlam kazandirilmis.
- TUR CIKARIMI TANIMLANAN DEGISKEN ICIN MI YAPILIYOR YOKSA AUTO SOZCUGU ICIN MI YAPILIYOR ? 
	CEVAP: TUR CIKARIMI AUTO ICIN YAPILIYOR.

- Ornegin;
	auto x		// auto icin yapilan cikarim int olsaydi, x'in turu de int olurdu
	auto& x		// auto icin yapilan cikarim int olsaydi, x'in turu int& olurdu
	auto *x		// auto icin yapilan cikarim int olsaydi, x'in turu int* olurdu

	YANI AUTO'YA KARSILIK GELEN TURLE DEGISKENIN TURU AYNI OLMAK ZORUNDA DEGIL!


- value kategory IFADEYI NITELEYEN BIR KAVRAM

	int x = 5;
	soru: x'in value kategorisi nedir?
	cevap: x'in value kategorisi yok ki? x bir degisken. IFADELERIN VALUE KATEGORISI OLUR. DEGISKENIN VALUE KATEGORISI OLMAZ.

	x -> bu ifadenin value kategorisi L value expression'dur.
	5 -> bu ifadenin value kategorisi PR value expression'dur.

- bir IFADENIN TURU REFERANS TURU OLAMAZ.
	ornek:
	int a = 5;
	int& r = a;

	r -> bu ifadenin turu int

- auto ile belirtilen degisken default initialize edilemez. Ya direct initialize edilecek ya da copy initialize edilecek.

- auto'da 3 tane kural seti var:

	1- auto x = expr;
	2- auto &x = expr;
	3- auto &&x = expr;

1- auto x = expr

	auto x = 10;	-> bu durumda auto'nun karsiligi olan tur dogrudan ilkdeger veren ifadenin turu.
	
	const int x = 10;
	auto y = x;	-> burada constluk duser. autonun karsiligi int olur.

	int x = 19;
	int& r = x;
	auto y = r;	-> burada y'nin turu int. CUNKU BIR IFADENIN TURU REFERANS OLAMAZDI. R IFADESININ TURU INT.

	eger boyle olmasaydi asagidaki kodun ciktisi 10 degil 999 olurdu. ama ciktisi 10:

	#include <iostream>
	using namespace std;
	int main()
	{
		int x = 10;
		int& r = x;
		auto y = r;
		y = 999;
		cout << "x =" << x << '\n';
	}

	Bir ornek daha :

	int x = 123;
	const int& r = x;
	auto y = r;

	y const da degil  int& de degil. y dumduz int.
	
	int ar[5]{};
	auto x = ar;	-> burada array decay ile aslinda &ar[0] yazilmis olur yani x int* olur.
	
	const int ar[5]{};
	auto x = ar;	-> burada array decay ile aslinda const &ar[0] yazilmis olur yani x const int* olur. 

	auto p = "fatih";	-> array decay olacak ve p const char* olacak

	int foo(int);
	auto x = foo;	-> int (*)(int);

	ozetle -> constluk duser
		  referanslik duser
		  array decay uygulanir
		  function to pointer conversion uygulanir
		  
2- auto &x = expr;

	auto& r = expr;	-> r l value referans olmali
	auto& r = 10; 	-> sentaks hatasi.!.!.

	const int x = 5;
	auto& r = x;	-> const'luk dusmuyor. auto yerine const int gelecek.

	array decay de olmuyor

	int ar[5]{1,2,3,4,5};
	auto x = ar; 	// x int* olacakti
	auto &r = ar;	// r int[5] olacak yani int(&r)[5]

	const int ar[5]{1,2,3,4,5};
	auto &r = ar;	// r -> const int(&r)[5]

	auto x = "fatih";	-> array decay var. x const char*
	auto& r = "fatih";	-> array decay yok. r const char(&r)[6]
	
	int foo(int);
	int main()
	{
		auto x = foo;		-> x'in turu int(*x)int		... yani auto icin cikarim int(*)(int)
		auto& r = foo;		-> r'nin turu int(&r)(int)	... yani auto icin cikarim int(int)
	}

	ozetle -> constluk dusmez
		  array decay uygulanmaz
		  funtion to pointer conversion uygulanmaz
		  
		 
3- auto &&x = expr; (universal reference(scot meyers demis) ya da forwarding referans (standartlarin terimi) denir)

	sag taraf referansi degil. type deduction ile && kullanilinca universal referans oluyor.

	auto&& r = x;	-> ilkdeger veren ifadenin ne olduguna bagli olarak r icin elde edilecek nihai tur ya L value referans
			   ya da R value referans turu olacak. 3. bir ihtimal yok.

	auto&& r = x;	//initializer L value yani asagidakine donusecek
	int& r = x;

	auto&& r = x + 3;	//initializer R value yani asagidakine donusecek
	int&& r = x;

	bu iki ornekte auto icin cikarilan turden bahsetmedik. r'nin turunden bahsettik.


	simdi gelelim auto tarafina... auto icin yapilan cikarim yine ilkdeger veren ifadenin ne olduguna bagli.

	ilkdeger veren ifadenin turu L value referans ise auto cikarimi -> T&
	ilkdeger veren ifadenin turu R value referans ise auto cikarimi -> T

	int x = 10;
	auto &&r = x; //oldugunda auto icin tur cikarimi T& yani...
	int& &&r = x; //referansa referans gibi bir durum olustu. ancak referansa referans olmaz. burada 
			derleyici REFERENCE COLLAPSING kuralini devreye sokuyor. Sadece burada degil birkac yerde daha karsimiza cikiyor.

	
	T&	&	->	T&
	T&	&&	->	T&
	T&&	&	->	T&
	T&&	&&	->	T&&

	int&    &&r      =       x;	-> yani burada tur T& oluyor. 
	





- decltype'tan da biraz bahsedelim.
- auto'da bir degisken tanimlayip ilkdeger verme zorunlulugu vardi.
- decltype kullanirken bir degisken tanimlamak gerekmiyor. tur gereken her yerde decltype ile cikarimi yapilan bir turu kullanabiliriz.
- decltype(10)
- decltype(x)
- decltype(x + 5)
- decltype(x.y)
- seklinde kullanilabilir.

- decltype'ta iki ayri kural seti var.
- ilk kurali basit, burada operandi bir isim formunda olacak. buna -> ve . operatoru ile erisilen isimler dahil.
	- decltype(a)
	- decltype(x)
	- decltype(a.y)
	- decltype(x->y)
	
- ikinci kural seti isim olmayan operandlar oldugunda uygulanir. 
	- decltype(10)
	- decltype(x + 11)
	- decltype((x)) // burada artik isim formunda degil. paranteze aldigim icin ifade formunda ele alacak ve ikinci
			   kural seti uygulanacak.


- 1. Kural seti, yani operandi isim formunda olanlar icin
	int x{};	
	decltype(x);	-> bunu artik int yerine kullanabiliriz.

	const int a {123};
	decltype(a);	-> const int (constluk falan dusmez)

	int& r = x;
	decltype(r);	-> int& turunden. 


	const int& r = x;
	decltype(r);	-> const int& turunden.


	int ar[40] {};
	decltype(ar);	-> int[40] turunden. 

	

	struct nec {
		int x;
		double* p;
	};
	nec mynec;
	decltype(mynec.p);	-> double* turu

	Yani operand olarak aldigi isim nasil bildirilmisse direkt o turden... 

	
- 2. Kural seti, yani operandi isim formunda olmayanlar icin
	
	decltype(expr) -> buradan elde edilecek ifadenin turu expr'in primary value kategorisine bagli. PR value, P

	value category of the expression

	operand olan ifadenin turu			elde edilecek tur
	PR						T
	L						T&
	X						T&&


	decltype(4);	-> bu tur int

	int x{5};
	decltype(+x);	-> bu tur int

	decltype(x++);	-> bu tur int

	decltype(++x);	-> bu tur int&. ++x bir L value expression oldugu icin elde edilecek tur int&

	int x{5};
	int * ptr = &x;
	decltype(*ptr);	-> elde edilecek tur int&. cunku *ptr L value expression belirtir.
	

	int x = 10;
	decltype (x); -> int
	decltype ((x)); -> int&



NOT: bir fonksiyonun geri donus degeri turu sag taraf degeri referansiysa o fonksiyona yapilan cagri ifadesinin kategorisi X value
	int bar();
	int& tar();
	int&& foo();
	//...
	foo()	-> X value

	decltype(bar())	-> int turu
	decltype(tar())	-> int& turu, yani ilkdeger vermek zorunlu
	decltype(foo())	-> elde edilen tur int&&

- decltype'a operant olan ifade icin islem kodu uretilmez. buna unevaluated context demistik.


##5. Ders##

C'deki scope'lar nelerdi?

	file scope (goto label'ları)
	block scope 
	function prototype scope
	function scope


C++'daki scope'lar

	namescape
	block scope 
	class scope
	function prototype scope
	function scope



SIRA ŞÖYLE GİDİYOR:

name lookup
	context control	
		access control (public, private falan onlarla ilgili)



- isim arama aranan isim bulununca biter. 

int x(int);
//...
int x = 5;
x(12);		// x fonksiyonu çağrılmaz. int değişkeni olan x'i buldu arama bitti. 
		// Buna name hiding, name masking ya da name shadowing demir.


mülakat sorusu:
int x = 5;
int main()
{
	int x = x;	// undefined behaviour!, Faaliyet alanı başlamış oluyor dolayısıyla kendi ile ilkdeğer veriyoruz.
			   çöp değer ile ilkdeğer vermek UB!
//...


int main()
{
	int printf = 0;
	printf("hello world");	// sentaks hatası, context controlde patlayacak. 
//...


ODR	(One Definition Rule)
- yazılımsal varlıkların sadece 1 tanımlaması olabilir ama birden fazla bildirimi olabilir.

ODR'ı çiğnemeyen istisnai durumlar:
	inline functions
	inline variable
	constexpr functions
	template definitions


birden fazla dosyada eğer inline fonksiyon özdeş olarak tanımlanırsa ODR ihlal edilmez.
Bir fonksiyonun tanımını inline olarak bir başlık dosyasına koyabiliriz. Derleyici inline expansion yapma şansına sahip olacak.
Sadece böyle geliştirme yapılarak yazılan kütüphanelere "header only library" denir.
inline expansion için derleyici o fonksiyonun tanımını görmek zorunda.

inline sözcüğü sadece tanımda, sadece bildirimde ya da her ikisinde de kullanılabilir.

C'deki inline ile mantıksal farklılıklar var!


C++17 ile birlikte inline variable da eklendi.
normalde c de global değişkeni her yerde kullanmak için 
header'da 
extern g_x;

kaynak dosyada 
g_x = 1;
şeklinde kullanacaktık.

doğrudan başlık dosyasında tanım yapsaydık yine ODR ihlal edilecekti.

artık c++17 ile farklı kaynak dosyalarda:
inline int g_x = 1;
şeklinde tanımlayabiliriz ve bu aynı adrese ilişkin bir değişken olur.



Enumaration Types

//örtülü dönüşüm.
C'deki hatanın mirası olarak aritmatik türlerden enum türlerine örtülü dönüşüm yok
fakat enum türlerinden aritmatik türlere örtülü dönüşüm var. Bu C++'ın gençlik günahlarından biri.

//underlying type
incomplete type olarak kullanamıyoruz.

enum Color;

struct Nec {

Color c;	// burada sizeof Color bilinmediği için incomplete type olarak kullanamıyoruz.
};

//aynı scope'taki aynı ismin birden fazla varlığa verilmesi sentaks hatası oluşturuyordu.
enum Color {Red, Green, Blue};
enum ScreenColor {Red, Magenta, Black};


artık underlying type seçilebilir oldu.
enum Color : unsigned int {blue, black, red};
incomplete type için olan sorun böylelikle çözülmüş oldu:

enum Color : unsigned int;

struct Data {
	//
	Color c; // buradaki storage ihtiyacını belirleyebilecek.
};


//scoped enum
enum class Color {blue, black, red};

modern c++ ile buna da underlying type belirtme özelliği geldi

enum class Color : unsigned char  {blue, black, red};

buradaki blue black ve red'i kullanılırken resolution operatörünü kullanmak zorunlu:
auto x = Color::red;

enum class Suit {Club, Diamon, Heart, Spade};
burada nitelendirmek için sürekli Suit::xxx kullanmak verbositeyi arttırıyor.
bunları çok kullandığın yerde using enum Suit; kullanabilirsin.

void func(Suit x)
{
	using enum Suit; //c++20 ile eklendi. artık nitelendirmek zorunda değilsin.
	//...
}

void func(Suit x)
{
	using Suit::Diamond; //c++20 ile eklendi. artık Diamond enum sabitini nitelendirmeden direkt kullanabilirim.
	using Suit::Diamond, Suit::Club; //c++20 ile eklendi. ya da birden fazla böyle belirtebilirim.
	//...
}





##6. Ders##

-Type cast operators

static_cast<target type>(operand)
const_cast<target type>(operand)
reinterpret_cast<target type>(operand)
dynamic_cast<target type>(operand)

	-----------------------------------------------------
	static_cast "standart dönüştürmeler (standard conversion)" için kullanılmaktadır. Standart dönüştürme demekle 
	aritmetik türler arası dönüştürmeler, enum ile nümerik 	dönüştürmeleri, void * dönüştürmeleri, türemiş sınıftan 
	taban sınıfa adres dönüştürmeleri kastedilmektedir.

	int ival = 190;
	int ival2 = 19;
	static_cast<double>(ival) / ival2;
	
	enum Fruit {apple, banana, pear};
	//...
	int ival = static_cast<int>(apple);
	
	int x{};
	void* vp {&vp};
	//...
	int* ip = static_cast<int *>(vp);
	
	enum class Fruit {apple, banana, pear};
	const char* const fnames[] = {"apple", "banana", "pear", "cherry"};
	//...
	fruit f {fruit::banana};
	fnames[static_cast<int>(f)];

	-----------------------------------------------------
	const_cast adres dönüştürmelerinde const'luğu atmak için (const away cast) kullanılmaktadır.
	const_cast const olmayan bir adresin const adrese dönüştürülmesinde de kullanılabilir.
	adres ya da referans semantiğinde kullanılır. Adres ya da referans olmadan kullanamazsın.
	
	int x{};
	const int* p = &x;
	int* ptr;
	ptr = const_cast<int*>(p);
	
	int x{};
	auto p = const_cast<const int*>(&x);	ama bunu zaten şöyle yazabiliriz const int* cp = &x;
	-----------------------------------------------------
	reinterpret_cast farklı türlerdeki adresler arasında ve adres türleriyle aritmetik türler arasında tür dönüştürmeleri için kullanılmaktadır.

	int* p = reinterpret_cast<int *>(0x1AC4);

	const int x = 54;
	reinterpret_cast<char *>(const_cast<int *>(&x));
	-----------------------------------------------------
	dynamic_cast kalıtım(inheritence) ve run time polymorfizim ile ilgili.




constexpr anahtar sözcüğü:
-bu sözcük bir specifier.

	-global değişkenlerin ilk değerini sabit ifadesi ile alması gerekir. C++'da fonksiyon ile de yapılıyor
	-dizi boyutu belirten ifadelerin constant expression olması gerekiyor.
	-switch'te case label'larını izleyen ifadelerin constant expression olması gerekiyor.
	- struct fatih {
		int x : 3;	//burada x bitfield member. : karakterinden sonraki ifade constant expression olması gerekiyor.
	  };
	
const int x = 10;
x	->	bu bir constant expression mu? yani compile time'da değeri belli mi? Cevap it depends. Onu initialize eden ifadenin ne olduğuna bağlı.
		x bir constant expression.

const int y = foo();
y	->	y bir constant expression değil.

-constexpr bir type qualifier değil.
constexpr int x = 56;	-> x int decleration type'ı const int (constexpr int değil)

bu tanımlama ne ifade ediyor?
bu değişkenin oluşturduğu ifadenin constant expression olarak kullanılma garantisi var.

-constexpr nitemelemesinin kullanılması için değişkenin literal type olması gerekir.
-constexpr değişkenine ilkdeğer veren ifade constant expression olmak zorunda.


-constexpr fonksiyon olunca ne oluyor?
-İlk çıktığında sadece 1 satır olmak zorundaydı şimdi neredeyse her kısıtlama kalktı.

	constexpr int func(int x)
	{
		return x * x + 5;
	}

- constexpr  bir fonksiyona çağrı yapılırken fonksiyon parametrelerine geçirilen argumanlar constant expression ise fonksiyon çağrı ifadesi
  constant expression gereken yerde kullanırsa constant expression belirtmek zorunda. Yani compile time'da elde edilmek zorunda. Bu mecburiyet
  constant expression gereken yerde kullanırsa geçerli!


 constexpr int a = func(2) + func(1);	// burada a'ya verilen ilkdeğer constexpr olmak zorunda olduğu için ve 2 ve 1 constant expression olduğu için	
					   ='in sağ tarafı compile time'da belirlenmek zorunda.

-constexpr fonksiyonlar implicitly inline fonksiyonlardır. Yani constexpr fonksiyonları başlık dosyalarında yazabiliriz.
-bunun inline expansion ile doğrudan bir alakası yok.
-bazı değerlerin compile time'da hesaplanması verimi artırıyor.
-bildirim ve tanım ikisinde de constexpr anahtar niteleyicisinin bulunması gerekiyor.




##7. Ders##

-function overloading
-function overloading compile time yöneliktir. Hangi fonksiyonla ilişkili olduğunu koda bakarak anlayabiliyor.
-function overloading aynı scopeta olacak ve isimleri aynı olacak
-aynı scopeta aynı isimli olacak fakat imzaları farklı olacak.
-fonksiyonunun geri dönüş değeri imzaya dahil değildir.
-imzaları da geri dönüş türü de aynıysa fonsiyon overloading değil redeclerationdur.
-imzası ve ismi aynıysa ama gdd farklıysa bu bir sentaks hatası.
-top level const'luk imzayı değiştirmez dolayısıyla function overload olmaz redecleration olur.
-tür eş ismi fn overloading olmasına yetmez.

void func(const int);
void func(int);			// bu ikisi redecleration. function overloading yok

void func(int *p);
void func(int * const p);		// bu ikisi redecleration. function overloading yok

void func(int *p);
void func(const int*  p);		// bunların ikisi farklı tür. function overloading var.	CONST OVERLOADING


void foo(int p[]);
void foo(int *p);	// redecleration. function overloading yok.

void foo(int p[8]);
void foo(int p[7]);
void foo(int p[5]);
void foo(int *p);		// burada 1 tane overload var.

void foo(int(*)[10]);
void foo(int(*)[12]);
void foo(int(*)[13]);		// 3 tane overload var

void foo(int(int));
void foo(int(*)(int));		//redecleration. üsttekinde function decay olacak ve alttakinin aynısı olacak.

void foo(int);
void foo(int&);
void foo(int*);
void foo(int&&);		//4 Tane overload var.

void foo(long double);
void foo(char);			// function overloading var.


FUNCTION OVERLOAD RESOLUTION

1- Function overload set oluşturuyor. Yani tüm overloadları listeliyor. Argumanları vs önemsiz bu aşamada. 
   Bu fonksiyonlara candidate functions denir.
2- Viable functions seçilir. Arguman sayısı ve parametre sayısı aynı olacak. Parametre türleri arasında örtülü dönüşüm olacak.
3- Viable sayısı birden fazlaysa dilin kurallarına göre uygunların içinden en uygunu seçecek(best match). Ya da ambiguity hatası olacak.


en kötü dönüşüm:					void func(...);		//variadic conversion her zaman herkese kaybediyor.
en kötünün bir iyisi user-defined conversion.:		yani constructor, operator overloading fonksiyonları falan.
3. kötü dönüşüm, standart dönüşümler:			legal dönüşümler(veri kaybı bile olsa üstteki ikisinden daha iyi bir dönüşüm.)

Ya eğer birden fazla standart dönüşüm varsa? en iyiden kötüye sıralama şöyledir:
	1- exact match
	2- promotion
	3- conversion

1- exact match:
-birebir aynı olan türler exact  match.
-T* ve const T* exact match.
-array decay exact match. 
-fonksiyon türünden fonksiyon adresi türüne dönüşüm exact match. Function to pointer conversion.
-L value to R value dönüşümü exact match. (yani fonksiyonu değişken ismi ile çağırmak gibi. foo(x);

2- promotion
integral promotion
	short
	unsigned short
	char
	signed char
	unsigned char
	bool

	Bu türlerden (int altı türlerden) int türüne olan promotion.

float -> double promotion (sadece bu promotion, diğerleri conversion)
	void foo(int);		//float->int conversion
	void foo(long double);	//float->long double conversion
	void foo(double);	//float->double promotion olduğu için bu kazanacak

	foo(3.4f);




	void foo(char);
	void foo(long double);
	
	foo(3.4);	//üstteki ikisi de conversion olduğu için ambiguity error!



	void foo(unsigned int);
	void foo(long double);
	
	foo(12);	//üstteki ikisi de conversion olduğu için ambiguity error!


	void func(int, int=0);
	void func(int);
	func(1);	//ambiguity!

	BİR İSTİSNA:
	void foo(void*);
	void foo(bool);
	int x = 10;
	func(&x);	// normalde ikisi de conversion olduğu için ambiguity olması gerekir. Ama bu bir istisna.
			   Burada void* olan çağrılır.
	
	
	void foo(int&);
	void foo(int&&);  //bunlar kesinlikle overload. L value ile çağırırsan üstteki, R value ile çağırırsan alttaki... 


	void foo(const T&);
	void foo(T&&);	
	int x{3};
	foo(x);		// L value parametreli olduğu için alttaki viable olmayacak. Üstteki çağrılacak.
	foo(11);	// Normalde her ikisi de viable. Ama dilin kuralı gereği (C++11) sağ taraf değeri olan çağrılacak. Taşıma semantiği ile ilgili nedenden dolayı.	
 			   void foo(T&&); çağrılır.

--------------------

asla unutmaman gereken bir soru:	
ekrana hangi yazı çıkacak?	
	foo fonksiyonlarına R valueyu gönderirsek üstteki, L valueyu gönderirsek alttaki çağrılacak. 
	func içindeki foo çağrısındaki r bir isim olduğu için L valıe expression. Dolayısıyla standart
	outputa "foo(const int&)" yazılır. Burada value category ile data type'ın birbiri ile karıştırılmasını 
	ölçüyor. Bir isim bir değişkene ilişkinse o L value expressiondur.

void foo(int &&)
{
	std::cout << "foo(int&&)\n;
}
void foo(const int &)
{
	std::cout << "foo(const int&)\n;
}
void func(int&& r)
{
	foo(r);
}
int main()
{
	func(123);
}


--------------------


void foo(int &&)
{
	std::cout << "foo(int&&)\n;
}
void foo(const int &)
{
	std::cout << "foo(const int&)\n;
}
int main()
{
	int x{10};
	1- foo(x);			// yukarıda öğrendiğimiz gibi burada x, L value expr olduğu için alttaki fonksiyon çağrılacak
	2- foo(static_cast<int&&>(x));	// burada R value expressiona cast ettik ve üstteki fonksiyonun çağrılmasını sağladık.
	3- foo(std::move(x));		// 2 numaralı işlemi yapan bir fonksiyon. Burada L value expr'dan R value  expr'a type cast yapmış olduk.
					// move fonksiyonunun gdd türü sağ taraf referans türü. Sağ taraf referans türüne dönen fonksiyonlara 
					// yapılan çağrı ifadesi x value expression idi. Yani x value olması demek R value olması demek.
					// Overload olan foo'da da R value expr olarak kullanmaya devam etmek için yine move fonksiyon çağrısı gerekir.
					// Yani bundan sonra hayatına R value expr olarak devam etmez.
}



--------------------

1- void func(std::nulptr);
2- void func(int*);

bir fonksiyonu özellikle nullptr ile çağırınca başka şeyler yapmasını istiyorsan 1'deki overload'ı yazman gerek. Çünkü exact match olduğu için 1 numaralı overload çağrılacak.


--------------------

birden fazla parametre olan fonksiyonlarda viable fonksiyon sayısı birden fazlaysa ambiguity olmaması için şunun sağlanması gerekiyor:
en az bir parametrede diğerlerinden iyi olacak ancak diğer parametrelerde diğerlerinden kötü olmayacak.



##8. Ders##

hatırlatma: data type ile value kategorisi farklı kavramlar. Bir ifadenin value kategorisi olur. İsim formundaki ifade R valueya ait olsa bile
L value referans overloadı çağrılır. Bunun örneği yukarıda var.

- C kodu ile C++ kodunu link ederken, C de fonksiyonlar C tarzı decorate ettikleri için link aşamasında problem olabilir.
Bu yüzden C'den gelen fonksiyonların dışsal bağlam olduğunu belirtmek için C++ dosyasında şöyle bir bildirim yapılmalı.

extern "C" int sum(int,int);

-biz başlık dosyası C'de derlenecek ama hem C hem de C++'da kullanılacak olsun. Bu durumda fonksiyon bildirimlerini C dosyaları
bu şekilde : int sum(int,int); ancak C++ dosyalarının bu şekilde görmesi gerekir: extern "C" int sum(int,int);
Bu durumda koşullu derleme komutlarından faydalanabiliriz.

            header.h
|--------------------------------|
|#ifdef __cplusplus		 |
|extern "C" {			 |	
|#endif				 |
|				 |
|	int foo(int,int);	 |
|	int bar(int,int);	 |
|	int tar(int,int);	 |
|				 |
|#ifdef __cplusplus		 |
|}				 |
|#endif				 |
|--------------------------------|



CLASSES-SINIFLAR

isim arama ile ilgili sıra şu şekildeydi:


name lookup	->	bir ismin hangi varlığa ilişkin olduğuna bakılması. ya başarılıdır ya başarısız. 1 kere yapılır
	context control		->	bulunan varlık ismin kullanımına uygun mu?
		access control (public, private, protected)	->	C'de olan bir şey değil. Erişim izni var mı?


örnek:

int func(int);
int main()
{
	int func = 4;
	func(1);	// Error! Burada üst satırdaki func'u gördü ve name lookup bitti. Context controlde hata oluştu.
}


------------------------------

-class'ın storage değeri nonstatic data member'ları kadardır. Fonksiyonlar storage'a etki etmez.
-sınıfların non-static veri elemanlarına birçok dilde instance-variable denir.
-sizeof hiçbir tür için 0 değeri olmaz. bir adres oluşması için boş sınıf bile olsa sizeof değeri 1 byte olur.
-sınıfların üye fonksiyonları için redecleration söz konusu olamaz. Sentaks hatası olur.
-class anahtar sözcüğü kullanınca varsayılan access specifier private'tır.
-struct anahtar sözcüğü kullanınca varsayılan access specifier public'tır.
-sınıfın non-static üye fonksiyonlarının implicit olarak sınıf nesnesinin adresini alıyor.
 Nec x;
 x.foo();	//bu tarz çağrımlarda aslında gizlice bu fonksiyona Nec* türünden
		  arguman geçmiş oluyoruz.

	İşte bu yüzden non-static üye fonksiyonlar bir sınıf nesnesi ile çağrılmalı.
	Örneğin 
	class Nec {
	public:
		void set(int,int);
	};
	//..
		Nec::set(3,4);	//error! namelookup'ta sıkıntı yok ama bir sınıf nesnesi ile çağırmadık.
	
		Nec mynec;
		mynec.set(1,5);	//doğru kullanım.

- 
class Nec {
public:
	void set(int,int);
private:
	int mx, my;
};

void Nec::set(int x, int y)
{
	mx = 1;		// mx önce scope içinde, sonra class scope'ta aranır
	my = 3;		// my önce scope içinde, sonra class scope'ta aranır
}
	
	Yerel bir mx olsaydı onu görecekti ve onu değiştirecekti.
	Burada da derleyici ilk değişkenine gizlice geçirilmiş olan sınıf nesnesinin adresini kullanır.


##9. Ders##

void set(double d);	// global fonksiyon
void Nec::set(int x)	// üye fonksiyon
{
	set(2.3);	// üye fonksiyon çağrılır
}
---------------------------------------------------------
class MyClass {
public:
	void  bar(double x);
private:
	void  bar(int x);
};
int main()
{
	MyClass m;
	m.bar(12);	//1- namelookup'ta iki overloadı da buldu.
			//2- function overload resolutiondan private'taki seçilecek
			//3- ama en son access control'de takılacak

			//o yüzden bu kod sentaks hatası.
}

Buradaki espri public, private farketmeksizin hepsinin aynı scope'ta olduğu için overload fonksiyondur.
Erişim kontrolü bu adımdan sonra yapılır.
---------------------------------------------------------
-Bir üye fonksiyonun accessor ya da mutator olduğunu nasıl anlayacağız?
Normalde global fonksiyonlarda aldığı nesne adresinin başında const yazıyorsa bu fonksiyonun
accesor olduğunu anlıyorduk. Ancak üye fonksiyonlarda sınıf nesnesinin adresi fonksiyonların başında
gizli bir şekilde yazıldığı için sentaks değişiyor.

-Parametre parantezi kapandıktan sonra const anahtar sözcüğü kullanılırsa böyle fonksiyonlara
const member function denir. 

class MyClass {
public:
	void  bar() const; 	// const member function
	void  tar() ; 		// non-const member function
};

-non-static fonksiyonun const üye fonksiyon olup olmaması sınıf nesnesinin veri elemanlarıyla doğrudan ilişkisi yok.
Sınıf nesnesinin problem domainindeki anlamı ile ilgisi var. Yani sınıfın veri elemanlarının değişip değişmemesi ile 
bu konunun hiçbir alakası yok. 

-Sınıfın veri elemanını değiştiren bir fonksiyon const olabilir mi? EVET.

-fonksiyon tanımda da bildirimde de const anahtar sözcüğü kullanılacak.

--------------------------------------------------------------------------
//Aşağıdaki kod semantik açıdan doğru olsa da sentaks açısından geçersizdir.

#include <iostream>

class Person {
public:
    std::string get_name() const;
private:
    int m_debug_count = 0;
};

int g{};

std::string Person::get_name() const;
{
    ++m_debug_count;    //error! const üye fonksiyon sınıf nesnesinin değerini değiştiremez.
}

int main()
{

    return 0;
}
--------------------------------------------------------------------------
// Bu semantik açıdan doğru olan değişikliği yapabilmek amacıyla sentaksa 
// uydurmak için değişkenin önüne mutable anahtar sözcüğü getirilir.

#include <iostream>

class Person {
public:
    std::string get_name() const;
private:
    mutable int m_debug_count = 0; // Dikkat!
};

int g{};

std::string Person::get_name() const
{
    ++m_debug_count;
}

int main()
{

    return 0;
}

--------------------------------------------------------------------------
-const bir nesne için sınıfın sadece const üye fonksiyonlarını çağırabiliriz.
--------------------------------------------------------------------------
this keyword

-global fonksiyonlarda this keywordu kullanılmaz.
-this sınıf nesnesinin kendisini temsil etmiyor, adresini temsil ediyor. Bu yüzden sınıf 
nesnesinin kendisini kullanmak istiyorsanız *this şeklinde dereference etmek gerekiyor.
-this pointerinin oluşturduğu ifade L value expression DEĞİL,
 this pointerinin oluşturduğu ifade PR Value  expressiondır.
-this anahtar sözcüğünün kullanıldığı bir senaryo şöyledir:
	
	#include <iostream>
	
	class Myclass {
	public:
	    void func(int x);
	};
	
	void fg1(Myclass*);
	void fg2(Myclass&);
	
	void Myclass::func(int x)
	{
	    fg1(this);  //hangi sınıf nesnesi ile çağrılırsa onun adresi ile fg1'e çağrı yap
	    fg2(*this); //hangi sınıf nesnesi ile çağrılırsa o sınıf nesnesi ile fg2'ye çağrı yap
	}
	
	int main()
	{
	    Myclass m;
	    m.func(12);
	    return 0;
	}


-this anahtar sözcüğünün kullanıldığı başka bir senaryo, fonksiyon hangi sınıf nesnesi ile çağrılmışsa 
 o sınıf nesnesinin adresi ile döndürmek için:

	#include <iostream>
	
	class Myclass {
	public:
	    Myclass* foo();
	};
	
	Myclass* Myclass::foo()
	{
	    //...
	    return this;
	}
	
	int main()
	{
	    Myclass m;
	    m.foo();
	}


-this anahtar sözcüğünün kullanıldığı başka bir senaryo, fonksiyon hangi sınıf nesnesi ile çağrılmışsa 
 o sınıf nesnesinin kendisi ile döndürmek için:

	#include <iostream>
	
	class Myclass {
	public:
	    Myclass& foo();
	};
	
	Myclass* Myclass::foo()
	{
	    //...
	    return *this;
	}
	
	int main()
	{
	    Myclass m;
	    m.foo();
	}

-Aşağıdaki ifadede de operator overload fonksiyonları da *this döndüğü için aynı nesne ile tekrar diğer operator overload 
fonksiyonlarını çağırmış oluyoruz.

    std::cout << 5 << 1.2 << 223L;
    cout.operator<< (5).operator<< (1.2).operator<<(223L);


-this pointerinin amaçları özetle şunlardır:
	*sınıf nesnesinin adresini veya kendisini global bir fonksiyona geçirmek.
	*üye fonksiyonun sınıf nesnesinin adresini veya kendisini döndürmesini sağlamak. 

- const üye fonksiyonlar için this bir low level const olur. Dolayısıyla aşağıdaki örnekte
  const T* gibi olan this pointerını T* gibi return etmeye çalıştığımız için error olur.
	
	class Myclass {
	public:
	    Myclass* foo() const
	    {
	        //...
	        return this; //Error!
	    }
	};

- Olayı anlaman için aşağıdaki kodda sentaks hatası yok.

	class Myclass {
	public:
	    const Myclass* foo() const
	    {
	        //...
	        return this;
	    }
	};

-Aynı durum referans semantiği için de geçerli.

- fonksiyonun const olması imzanın bir parçası. Overload olur.

	class Myclass {
	public:
		void foo();
		void foo() const; //imzası farklı
	};

	Burada bir örnek vermek gerekirse vector sınıfının iki overload olan at fonksiyonu vardır.
	Biri set etmek için diğeri get etmek içindir.
	
	Vector vec;
	vec.at(3) = 11;		//const olmayan overload
	auto x = vec.at(5);	//const olan overload

--------------------------------------------------------------------------
-Sınıfın üye fonksiyonunu inline fonksiyon yapmanın yolları:
	*fonksiyonun tanımını başlık dosyası içinde yapmak ve inline keyword'ünü kullanmak. (ODR çiğnenmeyecek)
	*fonksiyonun tanımını direkt sınıf içinde yaptığında  inline keyword'ünü kullanmasan bile inline yazmış olursun.

-Inline fonksiyon içerisinde incomplete type bulunamaz.

--------------------------------------------------------------------------
##10. Ders##

Sınıf Nesnelerinin Hayata Başlaması 
Sınıf Nesnelerinin Hayatlarının Sonlanması

-constructor'ın const üye fonksiyon olması yasak!
-constructor'ın static üye fonksiyon olması yasak!

-özel üye fonksiyonlar(special member function) modern cpp'den önce 4 taneydi, sonrasında 6 tane oldu
derleyici bunların kodunu belirli koşullar altında bizim için yazabiliyor.
	*default constructor
	*destructor
	*copy ctor
	*move ctor		(c++11 ile eklendi)
	*copy assignment
	*move assignment	(c++11 ile eklendi)

Bu terimin ingilizcesi : to default a special member function (derleyicinin kodu kendi yazması)

-her constructor bir special member function değildir.

-static initializiton fiasko:	aynı kaynak dosyadaki global değişkenlerin hayata geliş sırası belli.(tanımlanma sırasına göre)
Fakat farklı kaynak dosyadaki global değişkenlerinki belli değil. Bu konu şu açıdan önemli. 

a.cpp
	C cx;
b.cpp
	D dx;
c.cpp
	O ox;


cx sınıf türündeki nesne sınıf içinde dx'i kullanıyorsa onu kullanabilmesi için dx'in hayatta olması lazım. Ama böyle bir
garanti yok. Böyle bir garanti varmış gibi farklı modüllerdeki global değişkenleri kullanmak kodu patlatabilir.

-static yerel değişkenler ait oldukları fonksiyon çağrılmazsa hayata gelmiyor. İlk kez çağrıldığında constructor çağrılıyor.
static yerel değişkenlerin sonlanması da main fonksiyonunun sonlanmasından sonra oluyor.

-Bir nesneyi bir referansa bağlamak yeni bir nesne oluşturmaz. Yani yeni bir ctor çağrılmaz.
 Bunlar assembly düzeyinde birer pointer.

	örn:
	Myclass mx;
	Myclass& r1 = mx;
	Myclass&& r2 = r1;	// bir kez ctor çağrılır

	örn:
	Myclass mx;
	Myclass&& r = move(mx); // bir kez ctor çağrılır

- Mülakatlarda sorulan eğlenceli bir soru. Döngü kullanmadan 1'den 100'e kadar sayıları ekrana yaz.


	#include <iostream>
	
	class Myclass {
	public:
	    Myclass()
	    {
	        static int x = 0;
	        std::cout << x++ << " ";
	    }
	};
	
	int main()
	{
	    Myclass ar[100];
	}

-Hangi durumlarda default ctor çağrılır?
	*bir sınıf nesnesini default initialize ettiğimizde. -> Myclass m;
	*bir sınıf nesnesini value initialize ettiğimizde. -> Myclass m{};

- Myclass m(); -> bu nedir?
	burada fonksiyon bildirimi var. most vexing parse.


-Bir fonksiyonun delete edilmesi:
	Fonksiyonun var olduğunun ama o fonksiyona yapılacak çağrının sentaks hatası olduğunun bildirilmesi demek.

	void foo(int) = delete;
	int main()
	{
	    foo(11); // ERROR! function "foo(int)" cannot be referenced -- it is a deleted function
	}

-delete ile bildirilen fonksiyon da overload'tır. Var olması function overload'ta seçilmesi demek. 
 Var ama çağırmak yasak.

	void foo(int) = delete;
	void foo(double);
	void foo(long);
	int main()
	{
	    foo(11); // ERROR! +2 overloads
  		     // function "foo(int)" cannot be referenced -- it is a deleted function
	}

-global fonksiyonlar ve üye fonksiyonlar delete edilebilir. 

-delete bildirimleri bazı özel durumlar dışında sınıfların special member fonksiyonları için kullanılır.
 Ama böyle bir zorunluluk yok.

-default bildirimi nedir?
	Programcı bir fonksiyonun kodunu derleyicinin yazması için default bildirimi yapar. Eski C++'ta yoktu.
 	Her fonksiyon default edilir mi? HAYIR.
	Sadece special member fonksiyonlar default edilebilir: 
		*default constructor
		*destructor
		*copy ctor
		*move ctor		(c++11 ile eklendi)
		*copy assignment
		*move assignment	(c++11 ile eklendi)



-modern C++ diyor ki, bu special member fonksiyonlar şu statülerden birinde olabilir:
	
	*not declared
	*user declared
	*implicitly declared
	
	class Myclass {
	public:
	    Myclass();			// user declared
	};


	class Myclass {
	public:
	    Myclass() = default;	// user declared
	};

	class Myclass {
	public:
	    Myclass() = delete;		// user declared
	};

	class Myclass {
	public:
	  				// implicitly declared
	};


Öyle durumlar var ki derleyici user declared bildirim olmasa dahi bir special member fonksiyonu
imlicitly declared ediyor. Bazen bildiriyor ama delete ediyor(C++11). Bazen bildiriyor ve default ediyor.

--------------------------------------------------------------------------
Member Initializer List(MIL)	ya da	Constructor Initializer	Sentaksı

- birinci seçenek sınıfın non-static veri elemanlarına MIL sentaksı ile ilkdeğer vermek. 
- MIL sentaksı ile bütün non-static veri elemanlarına ilkdeğer vermek zorunlu değil.
  Diğerleri default initialize edilmek zorunda.
- Bazı durumlarda MIL sentaksı kullanmamak default initialize etmeye yol açacak o da sentaks 
  hatasına sebep olacak. Örneğin referanslara ilkdeğer vermek zorunlu olduğu için MIL sentaksı
  kullanılmalı.
- Bir diğer örnek bir sınıf türünün veri elemanı default initialize edilen başka bir sınıf türü
  olabilir. Ama o başka sınıf türünün default ctor'u olmayabilir. Bu durumda MIL sentaksı kullanmamak
  sentaks hatası olur.

	örnek:

	class Myclass {
	public:
	    Myclass(): mx(12), my(34){} // MIL sentaksı
	
	private:
	    int mx;
	    double my;
	};

- veri elemanlarının hayata gelme sırası için bildirimdeki sıra mı yoksa MIL sentaksındaki sıra
  mı esas alınacak? BİLDİRİMDEKİ SIRA ESAS ALINIR. (mülakatlarda da sorulur.)

	class Myclass {
	public:
	    Myclass(): my(12), mx(my/3){}; //undefined behaviour, my henüz çöp değerde
	
	private:
	    int mx;     //buradaki sıraya göre hayata gelir.
	    double my;
	};

-Default member initializer: Eğer sınıfın herhangi bir ctor'unda veri elemanlarına ilkdeğer VERMEZSEN
 o veri elemanlarına aşağıdaki sentaks ile VARSAYILAN olarak İLKDEĞER verebilirsin.

	class Myclass {
	public:
	    Myclass()
	    {
	        
	    }
	
	private:
	    //default member initializer
	    int mx = 0;     		// ya da -> int mx{0}; double my{0};
	    double my = 0;		// ama bu olmaz !!!! -> int mx(0); double my(0);
	};


-Modern C++ ile gelen en önemli kurallardan biri:
	Eğer derleyici imlicitly declare ettiği bir special member fonksiyonu tanımlama sürecinde
	dilin kurallarını çiğneyen bir durum oluşursa derleyici default etmesi gereken special 
	member fonksiyonu delete eder.


	Soru: Aşağıdaki sınıfın default ctor'unun durumu ne?

	class Myclass {
  
	private:
	    int& r;
	};

	Cevap: derleyeci tarafından delete edilir. Neden? Derleyicinin yazacağı default ctor
		aşağıdaki gibi olacak ve default initialize edilecek. Referansın default
		initialize edilmesi sentaks hatası olacak.
		Myclass() : r();
	
		Burada üstteki kural gerçekleştiği için bu ctor delete edilecek
		Myclass() : r() = delete;



	Örnek:
		#include <iostream>
		class Nec {
		    Nec();
		};
		
		class Myclass {
		public:  
		
		private:
		    Nec mnec;
		};

	
	Nec'in default ctor'u private. Derleyici Myclass sınıfı için default ctor'u yazarken mnec 
	değişkenini default initialize etmek isteyecek ve Nec'in default ctor'unu çağıracak. Ama Nec'in
	default ctor'u private idi. Onu çağırmak sentaks hatası olacak. Bu yüzden Myclass'ın default ctor'u 
	delete edilecek.

	#include <iostream>
	class Nec {
	    Nec();
	};
	
	class Myclass {
	public:  
	
	private:
	    Nec mnec;
	};
	
	int main()
	{
	    Myclass mx; // ERROR! the default constructor of "Myclass" cannot be referenced -- it is a deleted function
	}



- Eğer derleyici dilin kurallarına göre, bir special member fonksiyonu implicitly declare ediyorsa, derleyicinin yazdığı bu
  fonksiyon her zaman non-static, public, inline üye fonksiyonudur.

- ctor'u sen nokta operatorüyle veya ok operatorüyle çağırmak sentaks hatası.
- destructor'u sen nokta operatorüyle veya ok operatorüyle çağırmak legal. (replecemant new 'de mi ne kullanılıyormuş)


##11. Ders##

-kopyalama semantiği ne demek?
	bir nesneyi bir başka nesnesinin değeriyle hayata getiriyoruz
	ya da bir nesneye bir başka nesnenin değerini atıyoruz

	bu durumda 

	1- bu nesneler birbirinden bağımsız yani bundan sonraki bu nesnelerin biri üstünde yapılan
	   işlemler diğerini etkilemeyecek.

	2- bu nesneler karşılaştırılabilir nesneler ise (equality comparable) bu nesneler eşit olacak.


copy constructur(cc diye kısaltırlar)

	örneğin şurada copy constructor çağrılır:

	Myclass m1;
	Myclass m2(m1);

- Bir sınıfın copy constructoru olmak zorunda. (delete, default vs edilmiş olabilir.)
- Derleyicinin yazdığı copy ctor sınıfın non-static, public ve inline fonksiyonudur.
- copy ctorun parametresi sınıf türünden sol taraf referansı.

	class Myclass {
	public:  
	    Myclass(const Myclass& r);      //copy constructor
	    //...
	};

- Derleyicinin yazacağı copy constructor aşağıdaki gibi olacaktır.

	#include <iostream>
	
	class Date {
	public:
	    Date(const Date& r) : md(r.md), mm(r.md), my(r.my) {}	// copy ctor.
	    Date(int d, int m, int y) : md(d), mm(m), my(y) {}
	private:
	    int md, mm, my;
	};
	
	int main()
	{
	    Date d1{11,03,1998};
	    Date d2 = d1;
	    
	    return 0;
	}

- Birinci senaryo; elimizde bir sınıf nesnesi varsa ve ikinci bir sınıf nesnesi ile buna ilk değer verirsek 
  copy ctor çağrılır demiştik.
	örn:
	Myclass m1;
	Myclass m2 = m1;

- İkinci senaryo ise bir fonksiyonun parametresinin sınıf türünden olması ve ona bu sınıfla 
  arguman geçilmesi.
	void foo(Myclass m);

- Üçüncü senaryo ise fonksiyonun return ifadesinin bir sınıf nesnesi olması. Ama burada copy elision
  devreye girebiliyor.

	class Myclass{};
	Myclass foo()
	{
		//..
	}

NOT: RAII idiomu nedir? Son derece kötü uydurulmuş bir acronym. bjarne stroustrup uydurmuş, dilin mucidi.
 (Resource acquisition is initialization). Kaynağın destructor tarafından geri verilmesine denir. Basit
 bir olaya verilmiş havalı bir isim.


-Biz hangi senaryolarda copy constructor yazmalıyız?
 Bir adres tutan sınıf nesnesi düşün, örneğin string. Bu sınıf türünden nesne ile başka bir nesneye 
 kopyalama yaptığımızda derleyicinin yazdığı copy ctor memberwise copy yapacak. Yani o anda aslında
 iki sınıf nesnesi de bellekte aynı yeri gösterecek. Bu durumda birinin ömrü bittiğinde onun destructoru
 bellekteki kaynağı geri verecek ve hayatı henüz bitmemiş olan nesne dangling pointer haline gelecek.
 İşte bu gibi durumların önüne geçmek için copy ctoru biz yazarız. Bunun bir örneği utillib.c'de string 
 sınıfında yazdığım copy ctor'da var.

- Derleyicinin yaptığı karşılıklı kopyalamaya shalow copy veya memberwise copy deniyor halk arasında.
- Bizim yazdığımıza deep copy deniyor halk arasında.

	bir copy constructor örneği:

	String::String(const String &r) 
	{
		if (r.m_str != nullptr) {
			m_str = new char[r.m_len + 1];
			strcpy(m_str, r.m_str);
		}
		else
			m_str = nullptr;
		m_len = r.m_len;	// bu işlemi MIL sentaksı ile de ilk önce yapabilirdik.
	}

----------------------------------
Myclass m1, m2;
//...
m1 = m2;
m1.operator=(m2);	// copy assigment operator function.

parametreleri şöyle:
Myclass &Myclass::operator =(const Myclass &r);

	bir copy assignment kod örneği:
	
	String &String::operator =(const String &r)
	{
		if (this == &r)		/* nesne kendisine atanmış mı? */
			return *this;
	
		delete[] m_str;
	
		m_len = r.m_len;
		m_str = new char[m_len + 1];
		strcpy(m_str, r.m_str);
	
		return *this;
	}

-Fonksiyon bloğunun ilk başında "self-assigment" var mı diye kontrol ettik. Etmeseydik sonrasında free edilmiş m_str yüzünden 
 tekrar dangling pointer durumu meydana gelecekti. 

##12. Ders##

-sınıfın eleman olan nesneleri zaten copy constructorı vs yazıldıysa yani sınıf türündense derleyici kendi
yazdığı copy ctor'da onların copy ctor'unu çağırıyor. Örneğin sınıfın veri elemanlarının türü string, vector
gibi standart kütüphanedeki sınıf türünden nesnelerse zaten onlar özel üye fonksiyonları var.


-Modern C++ öncesi BİG 3 diye bir kavram vardı.

Dectructor
Copy constructor
Assignment

Big 3'e göre: Dectructor'ın yazımını derleyiciye bırakmak yerine kendiniz yazmak zorunda hissediyorsanız
o zaman diğer iki fonksiyonu da yazmalısınız. Çünkü destructor'un yazılma nedeni bir kaynağı bırakmak olduğu
için diğerlerini derleyicinin yazması uygun düşmeyecek.

-Bu kural artık kullanılmıyor çünkü işin içine move'lar girdi. Artık Big 5 diyebiliriz.

-----------------------------------------------------------------
Aşağıdaki kodda main'de bütün foo'lar 2 numaralı overload'ı çağırır. Hepsi R value expression.
Ancak 2 numaralı overloadın silinmesi sentaks hatası oluşturmaz çünkü const T& parametresine hem 
R value hem L value expreesion bağlanabiliyordu. 2. overloadın silindiğinde oluşan duruma "fallback"
denir. 

	#include <iostream>
	
	class Nec{};
	
	void foo(const Nec&); //1
	void foo(Nec&&); //2
	
	Nec bar();
	Nec&& baz();
	
	int main()
	{
	    Nec mynec;
	
	    foo(Nec{});
	    foo(std::move(mynec));
	    foo(bar());
	    foo(baz());
	    
	}

-Move ctor'daki mantık şöyle: bir sınıf nesnesi ölmek üzereyken kaynaklarını başkası tarafından çalınması.
Kaynakları çalınan nesnenin gösterdiği bellek alanı artık nullptr olacak, tekrar destructor çağrılırken bu durum 
dangling pointer oluşturmayacak mı? İşte öyle bir kod yazacağız ki destructor'da kaynaklarının çalındığını anlayacak.
Aynı şekilde str = s gibi bir atamada artık s nesnesinin gidici olduğunu biliyor ise o durumda da move assignment devreye girecek.

Özetle yapılan iş: 	*deep copy yapmak
			*diğer nesnesnin kaynağını çalmak
			*diğer nesne için destructor çağrıldığında kaynağın geri verilmemesini sağlamak.

-Gidici nesneler sağ taraf değeri ifade. Bu yüzden sağ taraf değeri argümanı alan overloadı seçecek. Sağ taraf referansı
kullanmak da mutator yapıyor yani "diğer nesne için destructor çağrıldığında kaynağın geri verilmemesini sağlamak."
maddesini gerçekleştirebiliyoruz.

	class Myclass {
	public:
		Myclass(const Myclass&);	// copy ctor (const L value referans parametreli)
		Myclass(Myclass&&);		// move ctor (R value referans parametreli)
	};

Bu durumda R value referans argumanlı çağrılar için move ctor, L value referans parametreli çağrılar için copy ctor çağrılır.
Herhangi bir nedenden dolayı move ctor yoksa, const T& türü hem R hem de L value'ya bağlanacağından dolayı ikisi için de copy ctor
çağrılır. Bu duruma "fallback" demiştik.

Aynı durum atamalar için de geçerli:

	class Myclass {
	public:
		Myclass(const Myclass&);	// copy ctor (const L value referans parametreli)
		Myclass(Myclass&&);		// move ctor (R value referans parametreli)

		Myclass& operator=(const Myclass&);
		Myclass& operator=(Myclass&&);
	};


-Derleyicinin yazdığı move ctor, elemanlara taşıma yapıyor, kopyalama yapmıyor. Sınıfın hem copy ctor'u
hem move ctor'u varsa, derleyici atamayı move ctor kullanarak yapacak.

-En sık yapılan hata şu ki ben de yaptım az önce:

	class myclass {
	public:
	    myclass(const myclass& r) : x(r.x), y(r.y),z(r.z){}
	    myclass(myclass&& r) : x(r.x), y(r.y),z(r.z){}  //!!!!! !!!!! HATA !!!!! !!!!!
	
	private:
	    int x,y,z;
	};

Peki neden?	->	myclass(myclass&& r) : x(r.x), y(r.y),z(r.z){}  //!!!!! !!!!! HATA !!!!! !!!!!
İsim formundaki ifadeler L value kategorisinde. Yani r'nin R value expression olması r.x'in R value expr olmasını
doğurmuyor. O halen L value expr. Bu yüzden onları da R value expr'e cast etmemiz gerekir. Aşağıdaki gibi...

	class myclass {
	public:
	    myclass(const myclass& r) : x(r.x), y(r.y),z(r.z){}
	    myclass(myclass&& r) : x(std::move(r.x)), y(std::move(r.y)),z(std::move(r.z)){}
	
	private:
	    int x,y,z;
	};


- Örneğin: 
Aşağıdaki sınıfta sınıfın move ctorunu yazmasam, bir Nec nesnesini hayata getiren bir R value Nec 
nesnesi olduğunda  derleyicinin yazdığı move ctor kullanılacaktı. Derleyicinin yazdığı move ctor da 
str elemanını string sınıfının move ctor'u ile hayata getirecekti. Benim bu durumda bir şey yapmam gerekmiyor.
Ama handle elemanlar varsa move ctoru kendim yazmam lazım.

	
	class Nec {
	
	private:
		std::string str;
		std::vector<int> vec;
	};

- Şimdi kendi yazdığımız string sınıfı için move contructoru yazalım:

String::String(String&& other): mlen(other.mlen), mp(other.mp)
{
	other.mp = nullptr;	// other için destructor çağrıldığında bizim çaldığımız kaynağı geri vermemeli.
	other.mlen = 0;
}
------------------------------------------------------------
Taşıma Semantiği ile ilgili bir soru:

	#include <iostream>
	
	class myclass {};
	
	void func(myclass&& r)
	{
	    
	}
	int main()
	{   
	    myclass m1;
	    func(std::move(m1));
	}

//1 - Yukarıdaki kodda func(std::move(m1)); çağrısıyla m1'in kaynağı çalınmış olur mu?
//    Hayır! Sadece R value referans değeri ile fonksiyona çağrı yaptık. Kaynak çalma işlemi 
//    func implementasyonu içinde yapılır.(yapılabilir.)
------------------------------------------------------------
//    Kaynak çalma işleminin iki yolu var. Ya bir myclass nesnesi hayata getireceğim ya da
//    bir my class nesnesine atama yapacağım.

Peki soru, aşağıdaki kod m1'in kaynağını çalmış olur mu?

	#include <iostream>
	
	class myclass {};
	
	void func(myclass&& r)
	{
	    myclass mx = r;
	}
	int main()
	{   
	    myclass m1;
	    func(std::move(m1));
	}

HAYIR! Yine aynı yere geldik. func implementasyonu içindeki r bir L value expression:  myclass mx = r;
Buradaki mx için copy ctor çağrılacak. Kaynağı çalması için oradaki r'nin bir R value expr olması gerek.

İşte aşağıdaki gibi bir kod olduğunda kendisine gelen sınıfın kaynağını çalar:

	#include <iostream>
	
	class myclass {};
	
	void func(myclass&& r)
	{
	    myclass mx = std::move(r); //mx move ctor edilir.
	}
	int main()
	{   
	    myclass m1;
	    func(std::move(m1));
	}

------------------------------------------------------------
- move assignment yazalım:

	class myclass {
	public:
	    myclass(const myclass& r) : x(r.x), y(r.y),z(r.z){}
	    myclass(myclass&& r) : x(std::move(r.x)), y(std::move(r.y)),z(std::move(r.z)){}
	    myclass& operator=(myclass&& r); //move assignment
	
	private:
	    int x,y,z;
	};

	myclass& myclass::operator=(myclass&& r)	// bu derleyicinin yazdığı move assignment
	{
		x = std::move(r.x);
		y = std::move(r.y);
		z = std::move(r.z);
		return *this;
	}

bizim yazacağımız gibi bir move assignment kod örneği:

bir move assignment kod örneği:
	
	String &String::operator =(String && r)
	{
		if (this == &r)		/* nesne kendisine atanmış mı? */
			return *this;
	
		std::free(mp);
		mlen = r.mlen;
		mp = r.mp;

		r.mp = nullptr;
		r.mlen = 0

		return *this;
	}

------------------------------------------------------------------------------------------------------------------------
-Öyle durumlar var ki bir L value expr'in ve hayatına normal devam eden nesnenin kaynağını çalmamız gerekiyor ve 
o nesne kaynakları çalınmış olarak hayatına devam ediyor.

örnek:

std::string str(1000, 'A');
std::string sx = std::move(str); // str'nin kaynağını çaldım.
//moved-from object/state

Bu noktadan sonra str'nin destructorunun çağrılması sorun oluşturmaz çünkü destructor ona göre yazılmış.
standart kütüphane (ve iyi 3rd party kütüphanelerde <bunu dokumante etmeliler>) şu garanti var.

a) kaynağı çalınmış nesne "in a valid state"te olacak
invariant'ları korunmuş olacak (örneğin string'in len'i vs)

b) nesne destructible olacak

c) nesneye yeni bir değer atayarak onu tekrar kullanabiliriz

Ama kaynağı çalınan nesnesinin hangi değerde olduğunu bilemiyoruz.


Bu durum için güzel bir örnek:

	#include <iostream>
	#include <fstream>
	#include <vector>
	#include <string>
	
	int main()
	{
	    std::ifstream ifs{"test.txt"};
	    if(!ifs) {
	        std::cerr << "cannot open file\n";
	        return 1;
	    }
	
	    std::vector <std::string> svec;
	
	    std::string sline;
	
	    while (getline(ifs, sline))
	    {       
	        //svec.push_back(sline); // bu şekilde copy ctor çağrılır ve çok maliyetli
	        svec.push_back(std::move(sline)); // bu şekilde move ctor çağrılır ve 
	                                          // döngünün her turunda sline nesnesi moved-from state durumundadır.
	    }
	    
	    //...
	}

------------------------------------------------------------------------------------------------------------------------
-Bazı durumlarda kopyalama semantiğini bir sınıfa vermek istemiyoruz. Çünkü bu durum ya problemli ya da saçma oluyor.
Bu durumdalarda kopyalama sentaks hatası haline getiriliyor. Örneğin bir mutex'in kopyalanması doğru değil. Bu durumlar için
copy ctor'u ve copy assignment'i delete hale getiriyoruz.

non-copiable sınıf örneği:

	class Nec {
	public:
		//...
		Nec();
		Nec(const Nec&) = delete;
		Nec& operator=(const Nec&) = delete;
	};

-Kopyalaması yasak ama taşımaya açık sınıflar için move-only class denir. Örneğin std::thread sınıfı. Yani yukarıdaki gibi.
------------------------------------------------------------------------------------------------------------------------

-Dilin kuralları net olarak hangi özel durumda sınıfın hangi özel fonksiyonunu derleyicinin imlicity olarak yazdığını
belirtiyor.

1- hiçbir üye fonksiyon tanımlamazsan 6 özel üye fonksiyonun hepsi imlicitly default edilecek.
2- Herhangi bir ctor tanımlarsan (özel olsun veya olmasın) örneğin int parametreli bir ctor, 
   default ctor hariç diğer 5 özel üye fonksiyon implicity default edilecek.
3- Eğer sadece default ctor bildirirsen diğer 5 özel üye fonksyion  implicity default edilecek.
4- Eğer  destructor bildirirsen,   sınıfın "move" memberları yok.
				   ctor ve "copy" memberlar implicity default edilecek.
		      		   ancak bu durum tehlikeli olduğu için deprecated edildi.

5- Eğer sadece copy ctor bildirirsen, sınıfın default ctor'u yok
				      sınıfın destructor'u implicity default edilecek.
				      copy assignmenti  implicity default edilecek.	 
				      "move"lar yok 

6- Eğer sadece copy assignment bildirirsen, default ctor implicity default edilecek.
					     destructor implicity default edilecek.
					     copy ctor implicity default edilecek.
                                             "move" memberlar  yok.

7- Eğer sadece move ctor bildirirsen,  default ctor yok.
				       destructor implicity default edilecek.
                                       copy ctor var ama delete edilir.
                                       copy assignment var ama delete edilir.
                                        move assignment yok.

8- Eğer sadece move assignment bildirirsen, default ctor implicity default edilecek.
					     destructor implicity default edilecek.
					     copy ctor var ama delete edilir.
                                             copy assignment var ama delete edilir.
                                             "move" ctor yok.


- bir sınıfın her zaman destructoru vardır.

- bir sınıfa eskiden büyük 3'lü denilen
	destructor
	copy ctor
	copy assignment
  bunlardan herhangi birini bildirirseniz derleyici "move" memberleri bildirmez. Yani sınıfın
  move memberları yoktur.

- bir sınıfa "move" memberlardan birini bildirirseniz derleyici "copy" memberları delete eder.

- "move"lardan birini yazarsan diğeri "not declared" olur. Yani mantıken diğer move'u da senin yazman lazım zaten.

- "copy"lerden birini yazarsan diğeri "defaulted" olur ama bu durum çok tehlikeli ve zaten deprecated edilmiş.

- sınıfın "copy" elemanları varken "move"ları delete etmek aptallıktan başka bir şey değil sakın yapma. Çünkü aşağıdaki gibi
  bir çağrı sentaks hatası olur.

	m1 = std::move(m2);

 Oysa "move" memberlar olmasaydı "copy"e fallback olacaktı.

<BURASI İÇİN BİR TABLO VAR>




##13. Ders##

Temporary Object (Geçici Nesneler)

-"Temporary Object" nesneler PR value expr'dir.
-"Temporary Object" nesneler içinde bulundukları expresiondan sonra hayata veda ederler.
-C++17 sonrası bu tarz ifadelere "temporary meterialization" denmiş.
-C++17 sonrası PR value expression olan geçici nesnelerin nesnenin kendisini değil de onu
 oluşturmaya yönelik adeta bir instructor olmasına "mandatory copy elision" denir.
 Burada copy ctor'u delete etsen bile sentaks hatası olmaz. Ama C++17 öncesi standartla
 derlersen hata olur.

copy elision
-Modern c++ öncesi bunlar derleyici optimizasyonu olarak yapılıyordu. Sonrasında zorunlu hale 
 getirildi.

örnek:
	myclass m = myclass{ myclass{myclass{}}};	//burada copy ctor çağrılmaz. 
							//sadece 1 ctor çağrılır.

örnek:
	void foo(myclass)
	{
	}
	int main()
	{
		foo(myclass{});
	}

Yukarıdaki kodda modern C++ öncesinde derleyici optimizasyonu olarak sadece default ctor
çağrılabilirdi ama move ctor veya copy ctor delete hale geldiğinde sentaks hatası verirdi.
Bu haliyle artık sentaks hatası yok, doğrudan default ctor çağrılacak.

örnek:
	myclass foo() //RVO
	{
		return myclass{};
	}
	int main()
	{
		myclass m = foo();
	}

c++17 ve sonrasında yine burada kopyalama yok. temporary metarialization var.

*Bir fonksiyonun geri dönüş türünün bir sınıf türünden olması ve fonksiyonun geri
dönüş değerini oluşturacak statement'ta PR value kullanılması durumuna popüler olarak
"Return Value Optimization (RVO)" denir.
------------------------------------------------------------------------------
örnek:
	myclass foo()
	{
		myclass x;
		//...
		return x;
	}
	int main()
	{
		myclass m = foo();
	}

*Derleyicinin ürettiği kod doğrudan myclass sınıf nesnesini geri dönüş değerinin yazılacağı yerde
oluşturması. Bu garanteed copy elision değil. Ama burada sınıfın copy ctor'unu delete etseydim sentaks
hatası olurdu. (Named Return Value Optimization (NRVO)) NRVO eski c++'ta da vardı.


------------------------------------------------------------------------------
conversion ctor (dönüştüren kurucu işlev)

-tek parametreli ctor'ların daha önce konuşmadığımız önemli bir özelliği var:

	#include <iostream>
	
	class Myclass {
	public:
	    Myclass() = default;
	    Myclass(int x)
	    {
	        std::cout << "Myclass(int) x: " << x << '\n';
	    }
	    
	};
	
	int main()
	{
	    Myclass m;
	    m = 5;
	}
	
	/*
	    * Sınıfların tek parametreli ctor'ları nesneyi oluşturmanın dışında 
	    parametresi olan türden (yukarıdaki örnekte int) bu sınıf türüne 
	    (bu örnekte Myclass) örtülü (implicit) dönüşümü sağlıyor.
	    Yani bu parametreli ctor sayesinde int -> Myclass implicit dönüşümü oluyor.
	
	    * Myclass(int) fonksiyonunu bildirdiğimde m = 5; kodu legal hale geldi.
	    Burada int -> Myclass dönüşümünü bu fonksiyona çağrı yaparak gerçekleştiriyor.
	
	    * m = 5 ifadesinde aslında bir geçici nesne oluşturuluyor. Derleyici durumdan vazife
	    çıkartarak Myclass(int) fonksiyonuna çağrı yaparak dönüşüm uyguluyor.
	
	    * Peki atama nasıl yapılıyor? move assignmet ile. (ama tablodan hatırla, copy assignment
	    yazarsan move assignment not declared olur ve copy assignment ile atama yapılır.)
	*/

-user defined conversion sadece conversion constructor değil. 
	* Biri şimdi gördüğümüz conversion ctor
	* Diğeri ileride göreceğimiz tür dönüştürme operator fonksiyonu
	  (type cast operator function) deniyor.
		#include <iostream>
		
		class Nec {
		public:
		    operator int()const;    //örtülü olarak Nec -> int dönüştürüyor.
		};
		
		int main()
		{
		    Nec mynec;
		    int ival;
		
		    ival = mynec;
		}
	   	
-user defined conversionu nasıl tanımladık: normalde standart olmayan öyle bir dönüşüm ki 
  bu dönüşümün örtülü olarak yapılabilmesi için derleyici bir fonksiyonu kullanıyor.

- Eğer bir örtülü dönüşüm (implicit conversion) önce standard conversion sonra user defined conversion
  yapılarak uygulanabiliyorsa böyle yapılmak zorunda. Bu dilin kuralı.

  Ya da bunun tersi olarak derleyici önce  user defined conversion sonra standard conversion uygulayabiliyorsa
  bunu yapmak zorunda. (ilerde göreceğiz)

  Eğer dönüşüm arka arkaya   user defined conversion +   user defined conversion olarak uygulanabiliyorsa bu
  hiçbir zaman örtülü olarak yapılmaz.

- örnek:
	class Myclass {
	public:
	    Myclass();
	    ~Myclass();
	    Myclass(int);
	    Myclass& operator=(const Myclass& r);
	};
	
	int main()
	{
	    Myclass m;
	    double dval{};
	    m = dval;
	}
	
	/*
	    m = dval;
	    m = flag;
	
	    Yukarıdaki kurallara göre bu ikisi geçerli mi? Evet. Çünkü bu  
	    gerçekleşmesi için dval'in önce double'dan int'e dönüşümü gerçekleşmeli.
	    Ve sonra da Myclass türüne dönüşüm gerçekleşmesi gerekiyor. 
	    double -> int : standard conversion
	    int -> Myclass: user-defined conversion
	*/
	--------------------------------------------------------------------------------
	class Myclass {
	public:
	    Myclass(){};
	    Myclass(bool);
	};
	
	int main()
	{
	    Myclass m;
	    m = "fatih sezen";
	}
	
	/*
	    Bu kodda görüldüğü gibi bu çok tehlikeli. Alakasız kodlar geçerli hale
	    geliyor. Birbiri ile mantıksal açıdan alakasız türler standard conversion
	    gerçekleştiği için standard conversion + user defined conversion oluyor.
	    Yukardıda array decay ile const char* türünden bool türünde standard
	    conversion oluyor. Sonra bu tür  Myclass(bool); fonksiyonuna çağrı yaparak
   	    bool -> Myclass dönüşümü oluyor.
	*/
	--------------------------------------------------------------------------------
- Son örnekteki problemin çözümü explicit constructor.
- Bir ctor'u explicit anahtar sözcüğü ile bildirmek o ctor'u explicit ctor yapıyor.
	class Myclass {
	public:
	    explicit Myclass(int x);
	};
- Bu ctor sadece explicit dönüşüme izin verir. Örtülü dönüşüme izin vermez. Bu ctor'larda dönüşüm
  yapmak için type cast araçlarını kullanmamız gerekiyor. 
	#include <iostream>
	
	class Myclass {
	public:
	    Myclass() = default;
	    explicit Myclass(int x);
	};
	
	int main()
	{
	    Myclass m;
	    m = 5; //ERROR! artık örtülü dönüşüme izin yok.
	}
- SINIFIN TEK PARAMETRELİ CTOR'LARINI EXPLICIT YAP! (%100 OLMASA DA ÖZEL DURUMLAR HARİÇ BU BÖYLE.)
	#include <iostream>
	
	class Myclass {
	public:
	    Myclass() = default;
	    explicit Myclass(int x);
	};
	
	int main()
	{
	    Myclass m;
	    m = static_cast<Myclass>(5); 
	}


-constructor'u explicit yaptığınızda;

	#include <iostream>
	
	class Myclass {
	public:
	    Myclass() = default;
	    explicit Myclass(int x);
	};
	
	int main()
	{
	    Myclass k(2);  //direct initialization sentaks hatası değil 
	    Myclass m{7};  //direct list initialization sentaks hatası değil
	    Myclass n = 4; //copy initialization sentaks hatası!!!!!!
	}

Buna standart kütüphaneden bir örnek:
	    unique_ptr<int> uptr = new int; // sentaks hatası !!!!
	    unique_ptr<int> uptr(new int); // sentaks hatası değil


NOTLAR:
-explicit anahtar sözcüğünü sadece bildirimde kullanacaksın. hem bildirim hem tanımda kullanmak sentaks hatası.
-static anahtar sözcüğünü sadece bildirimde kullanacaksın. hem bildirim hem tanımda kullanmak sentaks hatası.
-noexcept specifier'ı hem bildirimde hem tanımda kullanacaksın.

	#include <iostream>
	
	class Myclass {
	public:
	    explicit Myclass(int);
	    Myclass(double);
	};
	
	int main()
	{
	    Myclass m = 12;
	}
	
	/*
	    Burada explicit ctor overload set'e dahil olmuyor. Bu kodda sentaks hatası
	    yok. double parametreli ctor çağrılır.
	*/

- Her sınıfın tek parametreli ctor'unun explicit olmasına gerek yok. Bazı durumlarda explicit olmaması daha 
  uygun görülmüş. Örneğin:

		string str = "Fatih Sezen";	//Legal. Explicit olsaydı error olurdu.


------------------------------------------------------------------------------------------------------------------------------

Delegating Constructor

- C++11 ile birlikte dile eklendi.
- Delege yapıcı fonksiyon çağrımı aslında bir yapıcı fonksiyonun diğerini çağırabilmesi özelliğidir. 
- Ortak kodları bir yerde toplamak için kullanılan bir araç. 
- Modern c++'dan önce sınıfa bir private bir fonksiyon ekleyip bunun içine ortak kodu yazıyorduk.
- Bunun dezavantajları : 
   - bu fonksiyonun private olması client'ların çağırmasını engelliyor ama biz sadece
     construuctorların çağırabilmesini isterdik.
   - örneğin init ismini verdiğimiz bu fonksiyonu ctor içinde çağırdık. Ama zaten çoktan non static
     data memberlar hayata gelmiş oluyor.
- Delege yapıcı fonksiyon çağrımı MIL sentaksında yapıcı fonksiyonun belirtilmesiyle sağlanmaktadır.
- MIL sentaksının yalnızca delege yapıcı fonksiyon çağrımını içermesi gerekmektedir.	
	Myclass(int x) : Myclass(x, x) , mz{123}{} //GEÇERSİZ!
- Bir yapıcı fonksiyonun MIL sentaksında delege yapıcı fonksiyon çağrımı varsa önce delege yapıcı fonksiyon 
  çağrılır sonra o yapıcı fonksiyonun ana bloğu işletilir. 
- Tabii bir yapıcı fonksiyon başka bir yapıcı fonksiyonu o da başka bir yapıcı fonksiyonu çağırabilir. 
- Ancak bu çağrımlar sırasında döngsüsel bir durum durum oluşursa programın akışı sonsuz döngüye girebilir. 
- Bu durum genel olarak "tanımsız davranış (undefined behavior)" oluşturmaktadır.

		#include <iostream>
		
		using namespace std;
		
		class Sample {
		public:
			Sample();
			Sample(int x);
			Sample(int x, int y);
			void disp();
		
			int a;
			int b;
			//...
		};
		
		Sample::Sample() : Sample(10, 20)
		{
			cout << "default constructor" << endl;
		}
		
		Sample::Sample(int x) : Sample(x, 10)
		{
			cout << "int constructor" << endl;
		}
		
		
		Sample::Sample(int x, int y) 
		{
			// ortak yapılması gereken şeylerü
			cout << "common codes..." << endl;
		
			cout << "int, int constructor" << endl;
		
			a = x;
			b = y;
		}
		
		void Sample::disp()
		{
			cout << a << ", " << b << endl;
		}
		
		int main()
		{
			Sample s;
			Sample k(10);
		
			s.disp();
			k.disp();
		
			return 0;
		}



##14. Ders##

friend declarations 
- Başka kodların private elemanlarına erişimi geçerli kılıyor.
- Global bir fonksiyon ya da başka bir sınıfın üye fonksiyonu bir sınıfın friend fonksiyonu yapılabilir. 
- Bir sınıfın tamamına friend'lik verilebilir. Oradaki tüm fonksiyonlar sınıfın private bölümüne erişebilir.

	class Myclass {
	public:
	    friend int foo(int); // global'deki bir fonksiyonu friend olarak bildirdik
	private:
	    int mx;
	    void bar();
	};
	
	int foo(int)
	{
	    Myclass m;
	    auto val = m.mx; // geçerli
	    m.bar(); // geçerli
	}

- friend bildirimi public, private, protected nerede tanımladığın hiçbir şeyi değiştirmiyor.
- friend fonksiyonları sınıfın içinde tanımlayabiliyoruz. Bunun önemini ilerde konuşacağız.
- friend fonksiyonu  global ise derleyici tanımını görmeden friendliği geçerli sayar.
- ancak başka bir sınıfın bir fonksiyonu friend ise onun tanımını görmeli. Forward decleration da yetmiyor.

	class Nec;
	
	class Myclass {
	public:
	    friend int Nec::foo(); //invalid friend decleration. Bildirimi görmesi gerekiyor.
	    friend int foo(int); // global'deki bir fonksiyonu friend olarak bildirdik, tanımına gerek yok.
	private:
	    int mx;
	    void bar();
	};

- class'ı friend yapmak için bildirim ya da tanım gerekmiyor. 

	class Myclass {
	public:
	    friend class Nec;	// Nec'in bütün üye fonksiyonları Myclass'ın private bölümüne erişebilecek.
	    
	};

- Burada tabii ki A'nın B'ye friendlik vermesi B'nin de A'ya friendlik verdiği anlamına gelmiyor.
- A -> B -> C burada C'nin üye fonksiyonları tabii ki A'nın private bölümüne erişemez.
- Bir sınıfın tüm private bölümünü değil de bir kısmını friendlik verebilir miyim? Bunu direkt olarak
  yapacak bir araç yok ama Attorney-client idiom'uyla bunu gerçekleştirebiliriz.

------------------------------------------------------------------------------------------------------------
Operator Overloading

- C'de structlar 4 operatorun operandı olabilirdi. ".", "&", "sizeof", "=" .
- C++'da sınıf türünden nesneler operand yapıldığında derleyici durumdan vazife çıkararak "operator function(s)" lara
  çağrı yapıyor.
- "Operator function"lar global (free) function da olabilir sınıfın non-static member function'u da olabilir.(static olamaz)
- compile time'a ait bir mekanizma.
- operatorlerin primitive türler için (tamsayı türleri, gerçek sayı türleri, pointer türleri gibi...) verdiği doğal
  bir çağrışım var. ival + ival2 gibi... 
- Örneğin complex sınıfı türünden iki nesne toplanamaz mı? Bu gibi durumlar için sınıf türlerinin algısal açıdan kolay 
  bir şekilde implementasyonu için operator overloading mekanizmasını kullanıyoruz.

Kısa Notlar
- Operandlardan en az biri bir sınıf türünden veya enum türünden olmalı. (enum türü olması özel bir durum.)
- Olmayan operatorun yüklemesi olamaz. Örneğin a1 @ a2 olamaz.
- İsimlendirme şöyle olmak zorunda. Örneğin operator+ , operator[] , operator* , operator=   gibi...
- Bazı operatorlerin overloadingi yasaklanmış: (sizeof) , (.) , (? :) (ternary operator) , (::) (scope resolution) ,
  (.*) 
- Bazı operatorler free function olamıyor. Sadece sınıfın üye fonksiyonu olarak overload edilmesi gerekiyor.
  Örneğin: () function call operator, [] subscript operator, -> member selection arrow, = assignment operator
           ve typecast operators
- Tüm operator fonksiyonları isimleriyle de çağrılabilir.
- Bir operator fonksiyonu hariç operator fonksiyonları default arguman alamazlar. Function call operatoru default
  arguman alabilir.
- Operatorlerin "arity"si değiştirilemez. Yani unary/binary olması değiştirilemez.
	binary için : 
	matrix x,y;
	global fonksiyon ise iki parametresi olacak, üye fonksiyon ise tek parametresi olacak(ilk parametre this zaten). 
	Aksi halde sentaks hatası.

	unary için :
	!uniqueptr;
	global ise bir parametresi olacak, üye fonksiyon ise parametresiz olacak. Aksi halde sentaks hatası.

- şu dört operatorun iki anlamı var. Dolayısıyla iki overload'ı da olabilir. Parametre sayısı açısında şaşırma.
	x + y	 
	+x 	//sign op

	x - y	//subtraction op
	-x	//sign op

	x & y	//bitwise and
	&x	//addres of 

	x * y	//multiplication op
	*p	//dereferencing op

- operator overload fonksiyonlarında function overload olabilir:
	örnek:	
		class Bigint;
		Bigint operator+(int)const;
		Bigint operator+(long)const;
		Bigint operator+(long long)const;
		
	örnek:
		int x = 10;
		double dval = 3.4;
		operator<<(cout.operator<< (x), "\n');
		operator<<(cout.operator<< (dval), '\n');

- operator oncelik seviyesi ve öncelik yönü değiştirilemez.

- global operator fonksiyonları neden var?

	 1. Sebep: sol operandın sınıf türünden olmaması durumunda onun bir üye fonksiyonu olamaz.
		örnek:
		x + 5	->	x.operator+(5);
	
		5 + x	->	Bunu ancak global operator fonksiyonlarıyla gerçekleştirebiliriz.
	
	 2. Sebep: bana ait olmayan bir sınıfla işlem yaparken... Örneğin bir matrixi standart çıkış akımına yazdırmak isteyelim:
		
		#include <iostream>
		
		class matrix {
		
		};
		
		std::ostream& operator<<(std::ostream&, const matrix);
		
		int main()
		{
		    matrix x;
		    std::cout << x; //inserter
		}

- Şu tarz fonksiyonlarda geri dönüş değeri türü sınıf türünden olmalı. 
	class matrix {
	public:
	    matrix operator+(const matrix&)const{
	
	    }
	};

  matrix& yapmaya çalışma. Çünkü yerel nesne referansı döndürmek tanımsız davranış. 
  Dinamik nesne olsa kim free edecek o da saçma. Bu şekilde maliyetli olur diye düşünüyorsan...:
	* Eğer return statementtaki ifade PR value ise mandotory copy elision olacak.
	* Sonucu tutacak otomatik ömürlü bir nesne ise Named Return Value Optimization'u bloke eden
	  bir ifade değilse o zaman zaten NRVO yapacak. Hadi onu da yapamıyor.
	* O zaman da move semantik devreye girecek.

- c++ core guidelines önerdi. convension'dan tutun const correctness'a kadar olan bir rehber. Huawei C++ standards gibi...

- "+" operatoru de "=" operatoru de overload edilmişse "+=" operatoru de otomatik overload edilir mi? HAYIR! Bu diğerleri için
  de geçerli.

- C++20 ile birlikte "==" yazdığınız zaman "!=" operator overloadini yazmamıza gerek yok.


##15. Ders##

- Operator fonksiyonlarını yazarken önemli bir seçim kriteri var:
1-Bunlar friend function olarak class definition içinde mi implemente edilsin?
2-Yoksa bunlar sadece bildirilip .cpp dosyasında mı tanımlansın?

Biz 1 no.'luyu seçtik. Bunu yapmamızın önemli nedenlerinden biri bu fonksiyonları "hidden friend" haline getirmek. 
Friend yapmamızın iki  tane önemli sonucu var:
Birincisi: global yapacağım operator fonksiyonu sınıfın private bölümüne erişemez. Erişemezse örneğin toplama işleminde
	   neyi toplayacak? O yüzden friendlik vermem lazım.

			
		#include <iostream>
		#include <ostream>
		#include <istream>
		
		class Mint {
		public:
			Mint() = default;
			explicit Mint(int x) : mval{x}{}
			
			friend [[nodiscard]] Mint operator+(const Mint& lhs, const Mint& rhs)
			{
				return Mint(lhs) += rhs;
			}
			friend Mint operator-(const Mint& lhs, const Mint& rhs);
			friend Mint operator*(const Mint& lhs, const Mint& rhs);
			friend Mint operator/(const Mint& lhs, const Mint& rhs);
		
			friend bool operator==(const Mint& lhs, const Mint& rhs);
			friend bool operator!=(const Mint& lhs, const Mint& rhs);
			friend bool operator<(const Mint& lhs, const Mint& rhs);
			friend bool operator<=(const Mint& lhs, const Mint& rhs);
			friend bool operator>(const Mint& lhs, const Mint& rhs);
			friend bool operator>=(const Mint& lhs, const Mint& rhs);
		
			Mint& operator+=(const Mint& other)
			{
				mval += other.mval;
				return *this;
			}
			Mint& operator-=(const Mint& other);
			Mint& operator*=(const Mint& other);
			Mint& operator/=(const Mint& other);
			Mint& operator%=(const Mint& other);
		
			/*
			gdd değeri neden std::ostream& ?
			Başka ifadelerin değerini verebilmem için (cout << mymint) burada 
			çağrılan nesnenin değeri stream nesnesinin kendisi olması gerekiyor.
			*/
			friend std::ostream& operator<<(std::ostream& os, const Mint& m) // inserter
			{
				return os << '[' << m.mval << ']';
			}
		
			friend std::istream& operator>>(std::istream& is, Mint& m)
			{
				return is >> m.mval;
			}
		
		private:
			int mval{};	
		};
		
		int main()
		{
			std::cout << "deneme";
			return 0;
		}

	

------------------------------------------------------------------------------------------------------------------------

++x;	// nesnenin değerinin bir fazlasını üretiyor
x++;	// nesnenin değerini üretiyor 

--y;	// nesnenin değerinin bir eksiğini üretiyor
y--;	// nesnesinin değerini üretiyor


C'de:
++x ve y++ 		// R Value expr
--x ve y-- 		// R Value expr

C++'da:
++x			// L value expr
x++			// R value expr

--x			// L value expr
x--			// R value expr


operator fonksiyonlarında önek ve sonek ++ ve -- fonksiyonlarının ayırt edilmesi ve geri dönüş değerleri meselesi...

Burada imzaları farklı kılmak için bir kural uydurulmuş.

//operator++() 			//önek
//operator++(int) 		//sonek

Bu parametreye pratikte arguman da geçmeyeceksin isim de vermeyeceksin. (illa vereceksen 0) Bu sadece imzayı farklı 
kılıp önek, sonek ayrımını yapmak için uydurulmuş bir kural.

önek ++'nın ürettiği değer L value expr
sonek ++'nın ürettiği değer R value expr	olduğu için gdd'ler şöyle olacak:

Mint& operator++() 			//önek
Mint operator++(int) 			//sonek

Mint& Mint::operator++() //önek
{
	++mval;
	return *this;
}

Mint& Mint::operator++(int) //sonek
{
	Mint retval{ *this };
	++*this;
	return retval;
}

-----------------------------------------------------------------------
sign operator olan "+" ve "-" ...

Mint Mint::operator+()const
{
	return *this;
}

Mint Mint::operator-()const
{
	return Mint(-mval);
}

-----------------------------------------------------------------------
logic değil operatoru...

[[nodiscard]] bool operator!()const
{
	return static_cast<bool>(mval);
}

-----------------------------------------------------------------------
array like sınıfların da kullandığı "[]" operator overloadı:

ar[i]			ar.operator[](i);
vec[5]			ar.operator[](5);
str[val]		ar.operator[](val);

-bunlar L value referense type üretmeli
ama mesela ar'ın elemanları int ise int gdd olmalı ya da str yazı tutuyorsa str[val] gdd si char& olmalı...

- const üye fonksiyon çağrılırsa const overloadı çağrılacak

char& operator[](std::size_t idx);
const char& operator[](std::size_t idx)const;

Normalde C'de ar[5] ya da 5[ar] yazdığımızda bir sentaks hatası oluşmuyordu.
Ama operator overloading olarak "[]" kullanıldığında artık 5[ar] gibi bir ifade yazamıyoruz.
Artık array decay de yok:	ar + 3 gibi bir ifade de geçersiz.

-----------------------------------------------------------------------
reference qualifiers
	
	class Bigint {
	public:
		// void func();	// Bu haliyle R value ile de L value ile de çağrılabilir.
		void func()&;	// Bu fonksiyon sadece  L value ile çağrılabilir.
	};
	
	int main()
	{
		A ax;
		ax.func();	// legal
		A{}.func();	// Sentaks Hatası! A{} ifadesi geçici nesne oluşturuyor yani PR value ref.
				// Dolayısıyla reference qualifier'lı fonksiyonu çağıramam.
	}

Tam Tersi de mümkün:

	class Bigint {
	public:
		// void func();	// Bu haliyle R value ile de L value ile de çağrılabilir.
		void func()&&;	// Bu fonksiyon sadece  R value ile çağrılabilir.
	};
	
	int main()
	{
		A ax;
		ax.func();	// Sentaks Hatası! ax ifadesi L value ref.
				
		A{}.func();	// Legal
	}


Sonuç olarak şu şekilde 3 tane overload oluşturabilirim:

	void func()const;
	void func()&&;
	void func()&;

Bunu kullanarak R value expr için farklı bir implementasyon, L value expr için farklı bir implementasyon kullanabilirim.
------------------------------------------------------------------------------------------------------------------------
##16. Ders##


	#include <iostream>
	#include <ostream>
	#include <istream>
	
	class Mint {
	public:
		Mint() = default;
		explicit Mint(int x) : mval{x}{}
		
		friend [[nodiscard]] Mint operator+(const Mint& lhs, const Mint& rhs)
		{
			return Mint(lhs) += rhs;
		}
		friend Mint operator-(const Mint& lhs, const Mint& rhs);
		friend Mint operator*(const Mint& lhs, const Mint& rhs);
		friend Mint operator/(const Mint& lhs, const Mint& rhs);
	
		friend bool operator==(const Mint& lhs, const Mint& rhs);
		friend bool operator!=(const Mint& lhs, const Mint& rhs);
		friend bool operator<(const Mint& lhs, const Mint& rhs);
		friend bool operator<=(const Mint& lhs, const Mint& rhs);
		friend bool operator>(const Mint& lhs, const Mint& rhs);
		friend bool operator>=(const Mint& lhs, const Mint& rhs);
	
		Mint& operator+=(const Mint& other)
		{
			mval += other.mval;
			return *this;
		}
		Mint& operator-=(const Mint& other);
		Mint& operator*=(const Mint& other);
		Mint& operator/=(const Mint& other);
		Mint& operator%=(const Mint& other);
	
		/*
		gdd değeri neden std::ostream& ?
		Başka ifadelerin değerini verebilmem için (cout << mymint) burada 
		çağrılan nesnenin değeri stream nesnesinin kendisi olması gerekiyor.
		*/
		friend std::ostream& operator<<(std::ostream& os, const Mint& m) // inserter
		{
			return os << '[' << m.mval << ']';
		}
	
		friend std::istream& operator>>(std::istream& is, Mint& m)
		{
			return is >> m.mval;
		}
	
	private:
		int mval{};	
	};
	
	int main()
	{
		std::cout << "deneme";
		return 0;
	}

------------------------------------------------------------------------------------------------

dereferencing & member selection (arrow) operator fonksiyonları
	
	#include <iostream>
	
	class Mint;
	
	class MintPtr {
	public:
		explicit MintPtr(Mint* p) : mp(p){}
		~MintPtr()
		{
			if (mp)
				delete mp;
		}
	
		// MintPtr(const MintPtr&) = delete;
		// MintPtr& operator=(const MintPtr&) = delete;
		//move memberlardan birini bildirmek copy'leri derleyici tarafından delete eder.
		MintPtr(MintPtr&& other) : mp(other.mp)
		{
			other.mp = nullptr;
		}
		MintPtr& operator=(MintPtr&& other)
		{
			delete mp;
			mp = other.mp;
			other.mp = nullptr;
		}
	
		Mint& operator*() //*ptr yapınca L val expr olması lazım o yüzden g.d.d. T& türden
		{
			return *mp;
		}
	
		Mint* operator->() // -> op. fonks. g.d.d %99 pointer olmalı.
		{
			return mp;
		}
	
	private:
		Mint* mp;
	};


------------------------------------------------------------------------------------------------

-fonksiyon çağrı operator fonksiyon default arguman da alabilir. Diğer overload 
fonksiyonları alamaz. 

    class Myclass {
    public:
        int operator()(int x);
    };
    //...
    Myclass mc;
    mc(5);
    
-fonksiyon çağrı operatoru overloadu ne işe yarıyor? Generic Programlamada işe yarayacak.

--------------------------------------------------------------------------------
type cast operator fonksiyonları

Eğer dilin kuralları gereği zaten yapılacaksa buna "standard conversion" deniyor.
Eğer dönüşüm bizim yazdığımız bir fonksiyona çağrı yapmak suretiyle gerçekleşiyorsa
buna "user-defined conversion" deniyor. Şimdiye kadar "conversion ctor" ile yapmayı gördük.
Şimdi 2. yolunu göreceğiz: tür dönüştürme operator fonksiyonu. Bu fonksiyon member fonksiyon
olmak zorunda.

Hangi fonksiyonlar member fonksiyon olmak zorunda?
    * subscript operator fonksiyonu
    * member selection arrow
    * assignment operator fonksiyonu
    * fonksiyon çağrı operator fonksiyonu
    * tür dönüştürme operator fonksiyonu


    #include <iostream>

    class Myclass {
    public:
        operator int()const
        {
            std::cout << "Myclass:operator int()\n";
            return 4;
        }
    };

    int main()
    {
        Myclass mc;
        int ival{};

        ival = mc;
        std::cout << "ival = " << ival << '\n';	//ival = 4
    }


    /*
    -g.d.d. yazılmama sebebi boşuna yazılmak istenmemesi. 
    -operator <hedef_tür>()
    -sınıf türünden hedef türüne örtülü dönüşüm yapar. (burada Myclass -> int)
    -const olup olmaması kararı bize ait.
    -hedef tür istediğim tür olabilir.
    */



- explicit anahtar sözcüğü kullanıldığında örtülü dönüşüme izin vermez:

    #include <iostream>

    class Myclass {
    public:
        explicit operator int()const;
    };

    int main()
    {
        Myclass mc;
        int ival{};

        //ival = mc;	                //error
        ival = static_cast<int>(mc);    // legal
        ival = (int)mc;                 // legal
        ival = int(mc);                 // legal
        ival = mc.operator int();       // legal

    }

- explicit anahtar sözcüğü sadece conversion ctor ve tür dönüştürme operator fonksiyonlarında
kullanılabiliyor.

-hedef tür primitive tür olmak zorunda değil. Başka bir sınıf türü de olabilir.

-hedef türün function pointer type olması durumunda bunun tür eş ismini hedef türe yazmalıyım.

    using fptr = int(*)(int);

    class Nec {
    public:
        operator fptr()const;
    }


-----------------------------------

#include <iostream>
#include <cstdlib>

class Fraction {
public:
Fraction(int nom = 0, int den = 1): m_nom(nom), m_den(den) {}

operator double()const
{
	return static_cast<double>(m_nom) / m_den;
}

private:
	int m_nom, m_den;

};

int main()
{
	Fraction f1(3, 7);
	Fraction f2(3);
	Fraction f3;
	double dval = f1;
}

-----------------------------------
ya da örneğin bir başka kullanım senaryosu:

string str {"fatih sezen"};
const char* p = str.c_str();
-----------------------------------
ya da örneğin bir başka kullanım senaryosu:

int x = 10;
reference_wrapper r = x; // operator int&() fonksiyonuna çağrı yapılıyor
++r;
cout << "x = " << x << '\n';    // 11 basar
--------------------------------------------------------------------------------------------------------------------------------------------
##17. Ders##












































































