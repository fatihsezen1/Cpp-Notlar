##1. Ders## ve ##2. Ders##
- C dilinde static omurlu degiskenlere ilk deger veren ifadeler constant expression olmak zorunda fakan C++'ta boyle bir zorunluluk yok.
  Ornegin;
  int g_x = foo();  //C'de gecersiz, C++'da gecerli 

- C dilinde bir structure'in gecerli olmasi icin en az 1 elemani olmasi lazim. Fakat C++'ta 'empty class' legal ve cok kullaniliyor.

- C dilinde struct gibi user-defined turlerde degisken tanimlarken struct anahtar sozcugunu de kullanmak gerekiyor.
  Ornegin;
  struct person ali;   //C'de boyle
  person ali;   //C++'ta boyle de olur. (ustteki gibi de olur)

- C++'ta compound literal yok, C'de var.
  Ornegin;
  (int[5]) {1,3,4,5,6};

- C'de enum turlerinden temel turlere ve tersine ortulu donusum var.
  Ornegin asagidaki kod C'de legal;
  
  enum Color {
    White, Gray, Red
  };
  enum Pos {
    Open, Ajar, Close
  };

  int main() 
  {
	enum Color mycolor;
	int x = 2;

	enum Pos pos = Gray;
	mycolor = 5;
	mycolor = x;
	int ival = mycolor;
  }

- C++'ta enum turlerinden tam sayi turlerine ortulu donusum var. Bu ozellik Necati Ergin'e gore tam bir utanc kaynagi ve
	dilin genclik gunahi. Ornegin;

	#include <iostream>
	enum Color {
		White, Gray, Red
	};
	int main()
	{
		Color mycolor = Gray;
		int x = mycolor;	// enum turlerinden diger turlere yok, temel turlere ortulu donusum var
	}

- Bu durumu ortadan kaldirmak icin enum Class eklendi (scoped enums). Artik her zaman bu enum turlerini kullanacagiz.
  Bu enum turlerini ileride isleyecegiz.

- C23'e kadar C'de enum turu int idi. c23 ile c'ye de eklenen underlying type ozelligini kullanarak enumartorlerin tipini biz 
  belirleyebiliyoruz.
  Ornegin;

  enum Color : unsigned char {White, Gray, Red};

- C++ standartlarinda main fonksiyonunun int olmasi zorunlu. Ama derleyiciler yine de derliyor.

- C++'ta main fonksiyonunda return 0; yazmazsan derleyici kendisi yaziyor.

- int foo(void)
  {
        //..
  }

  Bu fonksiyon C'de undetermined value dondurur. ancak C++'da sentaks hatasi. (return yok)

- C'de main icinde main recursive olarak cagrilabiliyor. Ancak C++'ta bu cagrim sentaks hatasi.

- C++'ta;
  T x; //default initialization. Indetermined value ile hayata gelir. Bu artik kotu bir teknik.

- zero-initilization isminde initilization gecmesine ragmen bir ilkdeger kategorisi degil!!!! 
  Bazi init kategorilerinde uygulanan bir surec. (sifirla, nullptr ile, false ile ilk deger vermek)

  static omurlu degiskenler zero-init sureci... 

- T x = expr;         //artik buna copy initialization diyoruz.

- int x(7);        //bu c'de yok. Direct initilization diyoruz.

- uniform initilization(standartlardaki ismi) == brace initilization(populer ismi)
  Bunu direct initilizationda kullanmak cok daha yaygin. Hem her seye boyle ilkdeger verebiliyoruz hem de daraltici 
  donusume (narrowing conversion) izin vermiyor.

  Ornegin;
        int x = val;        //copy init
        int y(val);        //direct init
        int z{val};        //direct list init

- bazi ifadeler hem bir function prototype hem de variable definition anlamina gelebiliyorsa burada fonksiyon bildiriminin 
  onceligi var.!!! Scot-meyers reis buna bir tanim uydurmus -> most vexing parse

  Bir Most Vexing Parse ornegi;

        class A {

	};
	
	class B {
		B(A);
	};
	
	int main()
	{
		B bx(A());	//burada ismi bx olan bir degisken tanimlanmiyor. Bu bir fonksiyon BILDIRIMI!
	}
	
	Bunun bir fonksiyon bildirimi yerine bir degisken tanimlamasi olmasi icin UNIFORM INITIALIZER SYNTAX kullanmamiz gerekiyordu.
	Yani su sekilde:
	
	B bx{ A() };
	  
Ozetle neden uniform init sentaksa ihtiyac duyulmus?
	*uniform olmasi
	*daraltici donusume izin vermemesi
	*most vexing parse'a izin vermemesi


- value initialization:
  int x{};	// value initializationun farki, ilk basamak olarak zero-init kullanilmasi. Burada x sifir degerinde. yani cop deger yerine sifir ile
   		   baslatmis olduk. 

- nullptr sabitinin turu nullptr_t. nullptr nullptr_t turunden bir SABIT.
         
- unaveluated context -> islem kodu uretilmeyen baglam
  ne demek bu unaveluated context?
  oyle yerler var ki dilin kurali geregi o ifade icin islem kodu uretilmiyor. C dilindeki tek ornegi sizeof operatoru:

  int x = 10;
  size_t sz = sizeof(x++);	// burada x degiskeninin degeri hala 10

  sizeof operatorunun operandi olan ifade icin islem kodu uretilmez.

  C++'ta bu konu bir kac farkli yerde karsimiza cikiyor. Bu durum tanimsiz davranis dogurmuyor.
  C++ icin ornekler:

  int(*p)[10] = malloc(sizeof(*p));
	soru: malloc fonksiyonuna arguman olarak ne gectik?
	cevap: *p ifadesinin degeri int*[10] yani 10 carpi sizeof int degerini gectim. Buradaki problem p'yi dereference etmis olduk. ama p henuz cop degerde. ama sizeof icinde
		oldugu icin unevaluated context oluyor, yani tanimsiz davranis olusturmuyor. Cunku sizeof icin islem kodu uretilmez.

  int a[4] = {0};
  sizeof(a[5]);		// a[5] normalde tanimsiz davranis ama islem kodu uretilmedigi icin unevaluated context.

 int *ptr = nullptr;
 decltype(*ptr);	// burada da unaveluated context oldugu icin nullptr'yi dereference etmek sorun olusturmuyor.
	

##3. Ders##

 
