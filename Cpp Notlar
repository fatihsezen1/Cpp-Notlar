##1. Ders## ve ##2. Ders##
- C dilinde static omurlu degiskenlere ilk deger veren ifadeler constant expression olmak zorunda fakan C++'ta boyle bir zorunluluk yok.
  Ornegin;
  int g_x = foo();  //C'de gecersiz, C++'da gecerli 

- C dilinde bir structure'in gecerli olmasi icin en az 1 elemani olmasi lazim. Fakat C++'ta 'empty class' legal ve cok kullaniliyor.

- C dilinde struct gibi user-defined turlerde degisken tanimlarken struct anahtar sozcugunu de kullanmak gerekiyor.
  Ornegin;
  struct person ali;   //C'de boyle
  person ali;   //C++'ta boyle de olur. (ustteki gibi de olur)

- C++'ta compound literal yok, C'de var.
  Ornegin;
  (int[5]) {1,3,4,5,6};

- C'de enum turlerinden temel turlere ve tersine ortulu donusum var.
  Ornegin asagidaki kod C'de legal;
  
  enum Color {
    White, Gray, Red
  };
  enum Pos {
    Open, Ajar, Close
  };

  int main() 
  {
	enum Color mycolor;
	int x = 2;

	enum Pos pos = Gray;
	mycolor = 5;
	mycolor = x;
	int ival = mycolor;
  }

- C++'ta enum turlerinden tam sayi turlerine ortulu donusum var. Bu ozellik Necati Ergin'e gore tam bir utanc kaynagi ve
	dilin genclik gunahi. Ornegin;

	#include <iostream>
	enum Color {
		White, Gray, Red
	};
	int main()
	{
		Color mycolor = Gray;
		int x = mycolor;	// enum turlerinden diger turlere yok, temel turlere ortulu donusum var
	}

- Bu durumu ortadan kaldirmak icin enum Class eklendi (scoped enums). Artik her zaman bu enum turlerini kullanacagiz.
  Bu enum turlerini ileride isleyecegiz.

- C23'e kadar C'de enum turu int idi. c23 ile c'ye de eklenen underlying type ozelligini kullanarak enumartorlerin tipini biz 
  belirleyebiliyoruz.
  Ornegin;

  enum Color : unsigned char {White, Gray, Red};

- C++ standartlarinda main fonksiyonunun int olmasi zorunlu. Ama derleyiciler yine de derliyor.

- C++'ta main fonksiyonunda return 0; yazmazsan derleyici kendisi yaziyor.

- int foo(void)
  {
        //..
  }

  Bu fonksiyon C'de undetermined value dondurur. ancak C++'da sentaks hatasi. (return yok)

- C'de main icinde main recursive olarak cagrilabiliyor. Ancak C++'ta bu cagrim sentaks hatasi.

- C++'ta;
  T x; //default initialization. Indetermined value ile hayata gelir. Bu artik kotu bir teknik.

- zero-initilization isminde initilization gecmesine ragmen bir ilkdeger kategorisi degil!!!! 
  Bazi init kategorilerinde uygulanan bir surec. (sifirla, nullptr ile, false ile ilk deger vermek)

  static omurlu degiskenler zero-init sureci... 

- T x = expr;         //artik buna copy initialization diyoruz.

- int x(7);        //bu c'de yok. Direct initilization diyoruz.

- uniform initilization(standartlardaki ismi) == brace initilization(populer ismi)
  Bunu direct initilizationda kullanmak cok daha yaygin. Hem her seye boyle ilkdeger verebiliyoruz hem de daraltici 
  donusume (narrowing conversion) izin vermiyor.

  Ornegin;
        int x = val;        //copy init
        int y(val);        //direct init
        int z{val};        //direct list init

- bazi ifadeler hem bir function prototype hem de variable definition anlamina gelebiliyorsa burada fonksiyon bildiriminin 
  onceligi var.!!! Scot-meyers reis buna bir tanim uydurmus -> most vexing parse

  Bir Most Vexing Parse ornegi;

        class A {

	};
	
	class B {
		B(A);
	};
	
	int main()
	{
		B bx(A());	//burada ismi bx olan bir degisken tanimlanmiyor. Bu bir fonksiyon BILDIRIMI!
	}
	
	Bunun bir fonksiyon bildirimi yerine bir degisken tanimlamasi olmasi icin UNIFORM INITIALIZER SYNTAX kullanmamiz gerekiyordu.
	Yani su sekilde:
	
	B bx{ A() };
	  
Ozetle neden uniform init sentaksa ihtiyac duyulmus?
	*uniform olmasi
	*daraltici donusume izin vermemesi
	*most vexing parse'a izin vermemesi


- value initialization:
  int x{};	// value initializationun farki, ilk basamak olarak zero-init kullanilmasi. Burada x sifir degerinde. yani cop deger yerine sifir ile
   		   baslatmis olduk. 

- nullptr sabitinin turu nullptr_t. nullptr nullptr_t turunden bir SABIT.
         
- unaveluated context -> islem kodu uretilmeyen baglam
  ne demek bu unaveluated context?
  oyle yerler var ki dilin kurali geregi o ifade icin islem kodu uretilmiyor. C dilindeki tek ornegi sizeof operatoru:

  int x = 10;
  size_t sz = sizeof(x++);	// burada x degiskeninin degeri hala 10

  sizeof operatorunun operandi olan ifade icin islem kodu uretilmez.

  C++'ta bu konu bir kac farkli yerde karsimiza cikiyor. Bu durum tanimsiz davranis dogurmuyor.
  C++ icin ornekler:

  int(*p)[10] = malloc(sizeof(*p));
	soru: malloc fonksiyonuna arguman olarak ne gectik?
	cevap: *p ifadesinin degeri int*[10] yani 10 carpi sizeof int degerini gectim. Buradaki problem p'yi dereference etmis olduk. ama p henuz cop degerde. ama sizeof icinde
		oldugu icin unevaluated context oluyor, yani tanimsiz davranis olusturmuyor. Cunku sizeof icin islem kodu uretilmez.

  int a[4] = {0};
  sizeof(a[5]);		// a[5] normalde tanimsiz davranis ama islem kodu uretilmedigi icin unevaluated context.

 int *ptr = nullptr;
 decltype(*ptr);	// burada da unaveluated context oldugu icin nullptr'yi dereference etmek sorun olusturmuyor.
	

##3. Ders##

- Referans semantigi

  C'deki pointerlar yerine C++ dilinde sunlar kullanilabilir:
  pointer, referans, smart pointer (bir sinifla temsil edilir), iteratorler

  3 tane referans kategorisi var:

  L value reference
  R value reference
  forwarding reference (universal ref.)

  hatirlatma:

  expression (ifade nedir)
  10
  x
  x + y

  bunlarin sonuna terminator atomu yani ; koyarsak statement olur.

  x;  -> mesela bu bir expression statement

  her ifadenin bir value kategorisi var.
  modern C++ ile tasima semantigi icin bu value kategorisi biraz degisti:

  primary value category
  	L value (Left val.)
	PR value (pure val.)
	X value (expiring val.)

  combined value category
	L value	 ya da	X value  -> 	GL value
	PR Value ya da 	X value  ->	R value


	   glvalue     rvalue			(combined value cat.)
	    /  \       /  \
	   /    \     /    \
	lvalue   xvalue    prvalue		(primary value cat.)


	C ve C++'dan bazi farkliliklar:
	
	++x
	--y 
	
	ifadelerinin deger kategorileri C'de R value, C++'ta L value
	
	ya da 
	
	x, y
	Bu ifade operandlari L value olsa bile C'de L value degil ancak C++'ta ikinci operator L value ise ifade L val expr olusturuyor.


  Referanslara devam edelim.

  int x = 10;
  int& r{x};	//alias, r demek x demek...

- bir referans bir degiskene bind oldugunda sonra baska degiskene bind edilemez.
- referanslar default initialize edilemez. Ilkdeger vermek zorunludur.
- yukaridaki kodda &r demek x'in adresi demek.
- int* const p = &x; -> const pointer to int, top level const, right const yani pointerin kendisi const. gosterdigi nesne const degil.
- const int* p = &x; ->  pointer to const int, low level const, left const yani pointerin kendisi const degil. gosterdigi nesne const.
- const int* const p = &x; ->  const pointer to const int. gosteren de gosterilen de const.

- iste L value referans sunun karsiligi 
	int x = 19;
	int* const p = &x;	//L val ref.ler rebindable degil bu yuzden const pointer to int gibi dusunebilirisin.
	int& r{x};
 
- ornek:
	int x{};
	int* p = &x;
	//p'nin yerine gececek r isimle L value ref tanimlarsak;
	int* & r{p};

	++*r;	//r demek p demek, dereferans p demek x demek, dolayisiyla x'i 0'dan 1'e arttirmis oluruz.


- T foo();	-> boyle bir fonksiyona yapilan cagri ifadesi R value expression
- T& foo();	-> boyle bir fonksiyona yapilan cagri ifadesi L value expression

	int g_x = 11;
	int& foo()
	{
		//..
		return g_x;
	}
	int main()
	{
		foo() = 234; //atamayi g_x degiskenine yapmis oluyorum.
		int& r {foo()};	
	}

- dolayisiyla asagidaki gibi fonksiyonlara mutator, set-function ya da setter deniyor
	void func(T &);



- Oyle bir referans tanimla ki a'ya bind edilsin:
	int a[5] {0};
	//a dizisini gosteren pointer -> int(*p)[5] = &a;
	int(&r)[5] = a;



- const correctness = const olmasi gereken her sey const olmali

	ornegin fonksiyon parametresi const olmasi gerekirken olmazsa const nesneleri arguman gecemeyiz. Ornegin;

	#include <iostream>
	using namespace std;
	
	void print_array(int* p, size_t size);
	
	int main()
	{
		const int a[5]{};
		print_array(a, 5);	//error: 'void print_array(int *,size_t)': cannot convert argument 1 from 'const int [5]' to 'int *
	}


	// iste const bir yerden bile eksik olursa her yere nufuz eder. Derleyici optimizasyon olanaklarini kisitlar.


- int x = 10;
  const int& r = x;	//salt okunur bir referans. Amac degistirmeye yonelik degilse bu kullanilmali. (Accessor)

- int& r{10}; 	//sentaks hatasi! neden? Cunku 10 L value expression degil.
- const int& r{10}; 	//sentaks hatasi degil. neden?
	bu durumda r referansi bu sabite BAGLANMIYOR. Derleyici bir TEMPORARY OBJECT olusturuyor. 
- double x{2.6};
  const int& r = x;		//burada sentaks hatasi yok. temporary object 2 degerini alir. const olmasa sentaks hatasi olurdu. 
	
SONUCTA;
parameteresi T & olan fonksiyon sadece L Value expression kabul eder,
parameteresi const  T & olan fonksiyon hem R value expr hem de  L Value expression kabul eder.



- C++11 ile gelen onemli 5-6 eklentiden bazilari : tasima semantigi, lambda ifadeleri, perfect forwarding
  bunlarda R value referans kategorisi kullanilacak.

- T && seklinde kullanilan referans R value referans belirtir.
- R value referans R value expression'a baglaniyor. L value expressiona baglanamiyor.
- R value expressionun L value referans baglanmasi sentaks hatasidir.
- L value expressionun R value referans baglanmasi sentaks hatasidir.

ozetle:
T &      ->	sadece L value expression'a baglanir.
const T& -> 	hem L hem R value expressiona baglanir.
T &&     -> 	sadece R value expression'a baglanir. 

##4. Ders##
 soru: asagidaki kodda bir problem var mi?
	
	#include <iostream>
	
	int& get_value()
	{
		std::cout << "enter an integer: ";
		int x{};
		std::cin >> x;
		return x;
	}
	
	int main()
	{
		int& ri = get_value();
		std::cout << ri << '\n';
		return 0;
	}
	
	cevap: evet, otomatik omurlu nesnenin referansini donduruyor. 20. satirda o degisken hakkin rahmetine kavusmus oluyor.
	
-default argument (varsayilan arguman):

- ornegin 
	int foo(int, int, int = 10);
- varsayilan argumanlarin hepsi en saga dayali olmasi gerekiyor.
  ornegin 
	int foo(int, int, int = 10, int ); // bu bir sentaks hatasi

- varsayilan arguman hem bildirimde hem tanimda olsa SENTAKS HATASI olacakti. Sadece fonksiyon bildiriminde yaziyoruz genelde.
- fonksiyonun parametresi referans olup varsayilan arguman alabilir.
- fonksiyonun  varsayilan argumani fonksiyon cagrisi alabilir.
- birden fazla fonksiyon bildirimi yapilabilir. bu bildirimler kumulatif olarak ele alinir. 
- daha onceki parametreler daha sonraki parametrelerde varsayilan arguman olarak kullanilamaz.



- type deduction ( tur cikarimi )
- auto type deduction
- C'deki auto otomatik omurlu oldugunu belirtmek icin olan bir keyword. Bu atil durumdaki sozcuge C++'ta yepyeni bir anlam kazandirilmis.
- TUR CIKARIMI TANIMLANAN DEGISKEN ICIN MI YAPILIYOR YOKSA AUTO SOZCUGU ICIN MI YAPILIYOR ? 
	CEVAP: TUR CIKARIMI AUTO ICIN YAPILIYOR.

- Ornegin;
	auto x		// auto icin yapilan cikarim int olsaydi, x'in turu de int olurdu
	auto& x		// auto icin yapilan cikarim int olsaydi, x'in turu int& olurdu
	auto *x		// auto icin yapilan cikarim int olsaydi, x'in turu int* olurdu

	YANI AUTO'YA KARSILIK GELEN TURLE DEGISKENIN TURU AYNI OLMAK ZORUNDA DEGIL!


- value kategory IFADEYI NITELEYEN BIR KAVRAM

	int x = 5;
	soru: x'in value kategorisi nedir?
	cevap: x'in value kategorisi yok ki? x bir degisken. IFADELERIN VALUE KATEGORISI OLUR. DEGISKENIN VALUE KATEGORISI OLMAZ.

	x -> bu ifadenin value kategorisi L value expression'dur.
	5 -> bu ifadenin value kategorisi PR value expression'dur.

- bir IFADENIN TURU REFERANS TURU OLAMAZ.
	ornek:
	int a = 5;
	int& r = a;

	r -> bu ifadenin turu int

- auto ile belirtilen degisken default initialize edilemez. Ya direct initialize edilecek ya da copy initialize edilecek.

- auto'da 3 tane kural seti var:

	1- auto x = expr;
	2- auto &x = expr;
	3- auto &&x = expr;

1- auto x = expr

	auto x = 10;	-> bu durumda auto'nun karsiligi olan tur dogrudan ilkdeger veren ifadenin turu.
	
	const int x = 10;
	auto y = x;	-> burada constluk duser. autonun karsiligi int olur.

	int x = 19;
	int& r = x;
	auto y = r;	-> burada y'nin turu int. CUNKU BIR IFADENIN TURU REFERANS OLAMAZDI. R IFADESININ TURU INT.

	eger boyle olmasaydi asagidaki kodun ciktisi 10 degil 999 olurdu. ama ciktisi 10:

	#include <iostream>
	using namespace std;
	int main()
	{
		int x = 10;
		int& r = x;
		auto y = r;
		y = 999;
		cout << "x =" << x << '\n';
	}

	Bir ornek daha :

	int x = 123;
	const int& r = x;
	auto y = r;

	y const da degil  int& de degil. y dumduz int.
	
	int ar[5]{};
	auto x = ar;	-> burada array decay ile aslinda &ar[0] yazilmis olur yani x int* olur.
	
	const int ar[5]{};
	auto x = ar;	-> burada array decay ile aslinda const &ar[0] yazilmis olur yani x const int* olur. 

	auto p = "fatih";	-> array decay olacak ve p const char* olacak

	int foo(int);
	auto x = foo;	-> int (*)(int);

	ozetle -> constluk duser
		  referanslik duser
		  array decay uygulanir
		  function to pointer conversion uygulanir
		  
2- auto &x = expr;

	auto& r = expr;	-> r l value referans olmali
	auto& r = 10; 	-> sentaks hatasi.!.!.

	const int x = 5;
	auto& r = x;	-> const'luk dusmuyor. auto yerine const int gelecek.

	array decay de olmuyor

	int ar[5]{1,2,3,4,5};
	auto x = ar; 	// x int* olacakti
	auto &r = ar;	// r int[5] olacak yani int(&r)[5]

	const int ar[5]{1,2,3,4,5};
	auto &r = ar;	// r -> const int(&r)[5]

	auto x = "fatih";	-> array decay var. x const char*
	auto& r = "fatih";	-> array decay yok. r const char(&r)[6]
	
	int foo(int);
	int main()
	{
		auto x = foo;		-> x'in turu int(*x)int		... yani auto icin cikarim int(*)(int)
		auto& r = foo;		-> r'nin turu int(&r)(int)	... yani auto icin cikarim int(int)
	}

	ozetle -> constluk dusmez
		  array decay uygulanmaz
		  funtion to pointer conversion uygulanmaz
		  
		 
3- auto &&x = expr; (universal reference(scot meyers demis) ya da forwarding referans (standartlarin terimi) denir)

	sag taraf referansi degil. type deduction ile && kullanilinca universal referans oluyor.

	auto&& r = x;	-> ilkdeger veren ifadenin ne olduguna bagli olarak r icin elde edilecek nihai tur ya L value referans
			   ya da R value referans turu olacak. 3. bir ihtimal yok.

	auto&& r = x;	//initializer L value yani asagidakine donusecek
	int& r = x;

	auto&& r = x + 3;	//initializer R value yani asagidakine donusecek
	int&& r = x;

	bu iki ornekte auto icin cikarilan turden bahsetmedik. r'nin turunden bahsettik.


	simdi gelelim auto tarafina... auto icin yapilan cikarim yine ilkdeger veren ifadenin ne olduguna bagli.

	ilkdeger veren ifadenin turu L value referans ise auto cikarimi -> T&
	ilkdeger veren ifadenin turu R value referans ise auto cikarimi -> T

	int x = 10;
	auto &&r = x; //oldugunda auto icin tur cikarimi T& yani...
	int& &&r = x; //referansa referans gibi bir durum olustu. ancak referansa referans olmaz. burada 
			derleyici REFERENCE COLLAPSING kuralini devreye sokuyor. Sadece burada degil birkac yerde daha karsimiza cikiyor.

	
	T&	&	->	T&
	T&	&&	->	T&
	T&&	&	->	T&
	T&&	&&	->	T&&

	int&    &&r      =       x;	-> yani burada tur T& oluyor. 
	





- decltype'tan da biraz bahsedelim.
- auto'da bir degisken tanimlayip ilkdeger verme zorunlulugu vardi.
- decltype kullanirken bir degisken tanimlamak gerekmiyor. tur gereken her yerde decltype ile cikarimi yapilan bir turu kullanabiliriz.
- decltype(10)
- decltype(x)
- decltype(x + 5)
- decltype(x.y)
- seklinde kullanilabilir.

- decltype'ta iki ayri kural seti var.
- ilk kurali basit, burada operandi bir isim formunda olacak. buna -> ve . operatoru ile erisilen isimler dahil.
	- decltype(a)
	- decltype(x)
	- decltype(a.y)
	- decltype(x->y)
	
- ikinci kural seti isim olmayan operandlar oldugunda uygulanir. 
	- decltype(10)
	- decltype(x + 11)
	- decltype((x)) // burada artik isim formunda degil. paranteze aldigim icin ifade formunda ele alacak ve ikinci
			   kural seti uygulanacak.


- 1. Kural seti, yani operandi isim formunda olanlar icin
	int x{};	
	decltype(x);	-> bunu artik int yerine kullanabiliriz.

	const int a {123};
	decltype(a);	-> const int (constluk falan dusmez)

	int& r = x;
	decltype(r);	-> int& turunden. 


	const int& r = x;
	decltype(r);	-> const int& turunden.


	int ar[40] {};
	decltype(ar);	-> int[40] turunden. 

	

	struct nec {
		int x;
		double* p;
	};
	nec mynec;
	decltype(mynec.p);	-> double* turu

	Yani operand olarak aldigi isim nasil bildirilmisse direkt o turden... 

	
- 2. Kural seti, yani operandi isim formunda olmayanlar icin
	
	decltype(expr) -> buradan elde edilecek ifadenin turu expr'in primary value kategorisine bagli. PR value, P

	value category of the expression

	operand olan ifadenin turu			elde edilecek tur
	PR						T
	L						T&
	X						T&&


	decltype(4);	-> bu tur int

	int x{5};
	decltype(+x);	-> bu tur int

	decltype(x++);	-> bu tur int

	decltype(++x);	-> bu tur int&. ++x bir L value expression oldugu icin elde edilecek tur int&

	int x{5};
	int * ptr = &x;
	decltype(*ptr);	-> elde edilecek tur int&. cunku *ptr L value expression belirtir.
	

	int x = 10;
	decltype (x); -> int
	decltype ((x)); -> int&



NOT: bir fonksiyonun geri donus degeri turu sag taraf degeri referansiysa o fonksiyona yapilan cagri ifadesinin kategorisi X value
	int bar();
	int& tar();
	int&& foo();
	//...
	foo()	-> X value

	decltype(bar())	-> int turu
	decltype(tar())	-> int& turu, yani ilkdeger vermek zorunlu
	decltype(foo())	-> elde edilen tur int&&

- decltype'a operant olan ifade icin islem kodu uretilmez. buna unevaluated context demistik.


##5. Ders##

C'deki scope'lar nelerdi?

	file scope (goto label'ları)
	block scope 
	function prototype scope
	function scope


C++'daki scope'lar

	namescape
	block scope 
	class scope
	function prototype scope
	function scope



SIRA ŞÖYLE GİDİYOR:

name lookup
	context control	
		access control (public, private falan onlarla ilgili)



- isim arama aranan isim bulununca biter. 

int x(int);
//...
int x = 5;
x(12);		// x fonksiyonu çağrılmaz. int değişkeni olan x'i buldu arama bitti. 
		// Buna name hiding, name masking ya da name shadowing demir.


mülakat sorusu:
int x = 5;
int main()
{
	int x = x;	// undefined behaviour!, Faaliyet alanı başlamış oluyor dolayısıyla kendi ile ilkdeğer veriyoruz.
			   çöp değer ile ilkdeğer vermek UB!
//...


int main()
{
	int printf = 0;
	printf("hello world");	// sentaks hatası, context controlde patlayacak. 
//...


ODR	(One Definition Rule)
- yazılımsal varlıkların sadece 1 tanımlaması olabilir ama birden fazla bildirimi olabilir.

ODR'ı çiğnemeyen istisnai durumlar:
	inline functions
	inline variable
	constexpr functions
	template definitions


birden fazla dosyada eğer inline fonksiyon özdeş olarak tanımlanırsa ODR ihlal edilmez.
Bir fonksiyonun tanımını inline olarak bir başlık dosyasına koyabiliriz. Derleyici inline expansion yapma şansına sahip olacak.
Sadece böyle geliştirme yapılarak yazılan kütüphanelere "header only library" denir.
inline expansion için derleyici o fonksiyonun tanımını görmek zorunda.

inline sözcüğü sadece tanımda, sadece bildirimde ya da her ikisinde de kullanılabilir.

C'deki inline ile mantıksal farklılıklar var!


C++17 ile birlikte inline variable da eklendi.
normalde c de global değişkeni her yerde kullanmak için 
header'da 
extern g_x;

kaynak dosyada 
g_x = 1;
şeklinde kullanacaktık.

doğrudan başlık dosyasında tanım yapsaydık yine ODR ihlal edilecekti.

artık c++17 ile farklı kaynak dosyalarda:
inline int g_x = 1;
şeklinde tanımlayabiliriz ve bu aynı adrese ilişkin bir değişken olur.



Enumaration Types

//örtülü dönüşüm.
C'deki hatanın mirası olarak aritmatik türlerden enum türlerine örtülü dönüşüm yok
fakat enum türlerinden aritmatik türlere örtülü dönüşüm var. Bu C++'ın gençlik günahlarından biri.

//underlying type
incomplete type olarak kullanamıyoruz.

enum Color;

struct Nec {

Color c;	// burada sizeof Color bilinmediği için incomplete type olarak kullanamıyoruz.
};

//aynı scope'taki aynı ismin birden fazla varlığa verilmesi sentaks hatası oluşturuyordu.
enum Color {Red, Green, Blue};
enum ScreenColor {Red, Magenta, Black};


artık underlying type seçilebilir oldu.
enum Color : unsigned int {blue, black, red};
incomplete type için olan sorun böylelikle çözülmüş oldu:

enum Color : unsigned int;

struct Data {
	//
	Color c; // buradaki storage ihtiyacını belirleyebilecek.
};


//scoped enum
enum class Color {blue, black, red};

modern c++ ile buna da underlying type belirtme özelliği geldi

enum class Color : unsigned char  {blue, black, red};

buradaki blue black ve red'i kullanılırken resolution operatörünü kullanmak zorunlu:
auto x = Color::red;

enum class Suit {Club, Diamon, Heart, Spade};
burada nitelendirmek için sürekli Suit::xxx kullanmak verbositeyi arttırıyor.
bunları çok kullandığın yerde using enum Suit; kullanabilirsin.

void func(Suit x)
{
	using enum Suit; //c++20 ile eklendi. artık nitelendirmek zorunda değilsin.
	//...
}

void func(Suit x)
{
	using Suit::Diamond; //c++20 ile eklendi. artık Diamond enum sabitini nitelendirmeden direkt kullanabilirim.
	using Suit::Diamond, Suit::Club; //c++20 ile eklendi. ya da birden fazla böyle belirtebilirim.
	//...
}





##6. Ders##

-Type cast operators

static_cast<target type>(operand)
const_cast<target type>(operand)
reinterpret_cast<target type>(operand)
dynamic_cast<target type>(operand)

	-----------------------------------------------------
	static_cast "standart dönüştürmeler (standard conversion)" için kullanılmaktadır. Standart dönüştürme demekle 
	aritmetik türler arası dönüştürmeler, enum ile nümerik 	dönüştürmeleri, void * dönüştürmeleri, türemiş sınıftan 
	taban sınıfa adres dönüştürmeleri kastedilmektedir.

	int ival = 190;
	int ival2 = 19;
	static_cast<double>(ival) / ival2;
	
	enum Fruit {apple, banana, pear};
	//...
	int ival = static_cast<int>(apple);
	
	int x{};
	void* vp {&vp};
	//...
	int* ip = static_cast<int *>(vp);
	
	enum class Fruit {apple, banana, pear};
	const char* const fnames[] = {"apple", "banana", "pear", "cherry"};
	//...
	fruit f {fruit::banana};
	fnames[static_cast<int>(f)];

	-----------------------------------------------------
	const_cast adres dönüştürmelerinde const'luğu atmak için (const away cast) kullanılmaktadır.
	const_cast const olmayan bir adresin const adrese dönüştürülmesinde de kullanılabilir.
	adres ya da referans semantiğinde kullanılır. Adres ya da referans olmadan kullanamazsın.
	
	int x{};
	const int* p = &x;
	int* ptr;
	ptr = const_cast<int*>(p);
	
	int x{};
	auto p = const_cast<const int*>(&x);	ama bunu zaten şöyle yazabiliriz const int* cp = &x;
	-----------------------------------------------------
	reinterpret_cast farklı türlerdeki adresler arasında ve adres türleriyle aritmetik türler arasında tür dönüştürmeleri için kullanılmaktadır.

	int* p = reinterpret_cast<int *>(0x1AC4);

	const int x = 54;
	reinterpret_cast<char *>(const_cast<int *>(&x));
	-----------------------------------------------------
	kalıtım(inheritence) ve run time polymorfizim ile ilgili.




constexpr anahtar sözcüğü:
-bu sözcük bir specifier.

	-global değişkenlerin ilk değerini sabit ifadesi ile alması gerekir. C++'da fonksiyon ile de yapılıyor
	-dizi boyutu belirten ifadelerin constant expression olması gerekiyor.
	-switch'te case label'larını izleyen ifadelerin constant expression olması gerekiyor.
	- struct fatih {
		int x : 3;	//burada x bitfield member. : karakterinden sonraki ifade constant expression olması gerekiyor.
	  };
	
const int x = 10;
x	->	bu bir constant expression mu? yani compile time'da değeri belli mi? Cevap it depends. Onu initialize eden ifadenin ne olduğuna bağlı.
		x bir constant expression.

const int y = foo();
y	->	y bir constant expression değil.

-constexpr bir type qualifier değil.
constexpr int x = 56;	-> x int decleration type'ı const int (constexpr int değil)

bu tanımlama ne ifade ediyor?
bu değişkenin oluşturduğu ifadenin constant expression olarak kullanılma garantisi var.

-constexpr nitemelemesinin kullanılması için değişkenin literal type olması gerekir.
-constexpr değişkenine ilkdeğer veren ifade constant expression olmak zorunda.


-constexpr fonksiyon olunca ne oluyor?
-İlk çıktığında sadece 1 satır olmak zorundaydı şimdi neredeyse her kısıtlama kalktı.

	constexpr int func(int x)
	{
		return x * x + 5;
	}

- constexpr  bir fonksiyona çağrı yapılırken fonksiyon parametrelerine geçirilen argumanlar constant expression ise fonksiyon çağrı ifadesi
  constant expression gereken yerde kullanırsa constant expression belirtmek zorunda. Yani compile time'da elde edilmek zorunda. Bu mecburiyet
  constant expression gereken yerde kullanırsa geçerli!


 constexpr int a = func(2) + func(1);	// burada a'ya verilen ilkdeğer constexpr olmak zorunda olduğu için ve 2 ve 1 constant expression olduğu için	
					   ='in sağ tarafı compile time'da belirlenmek zorunda.

-constexpr fonksiyonlar implicitly inline fonksiyonlardır. Yani constexpr fonksiyonları başlık dosyalarında yazabiliriz.
-bunun inline expansion ile doğrudan bir alakası yok.
-bazı değerlerin compile time'da hesaplanması verimi artırıyor.
-bildirim ve tanım ikisinde de constexpr anahtar niteleyicisinin bulunması gerekiyor.




##7. Ders##

-function overloading
-function overloading compile time yöneliktir. Hangi fonksiyonla ilişkili olduğunu koda bakarak anlayabiliyor.
-function overloading aynı scopeta olacak ve isimleri aynı olacak
-aynı scopeta aynı isimli olacak fakat imzaları farklı olacak.
-fonksiyonunun geri dönüş değeri imzaya dahil değildir.
-imzaları da geri dönüş türü de aynıysa fonsiyon overloading değil redeclerationdur.
-imzası ve ismi aynıysa ama gdd farklıysa bu bir sentaks hatası.
-top level const'luk imzayı değiştirmez dolayısıyla function overload olmaz redecleration olur.
-tür eş ismi fn overloading olmasına yetmez.

















